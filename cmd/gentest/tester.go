
// Auto generated by fvecgen on %s
// Edit at your own risk
//

package main

import (
	"github.com/wyndhblb/fvec"
	"strings"
)

type GenTT struct {
	Name *fvec.VName

	Col1 *fvec.StringType `json:"col1" cql:"col1" msg:"col1"`

	Col2 *fvec.VMStrTPStrInt `json:"col2" cql:"col2" msg:"col2"`

	Col3 *fvec.CounterType `json:"col3" cql:"col3" msg:"col3"`

	Col4 *fvec.DoubleType `json:"col4" cql:"col4" msg:"col4"`

	Col5 *fvec.VSInt `json:"col5" cql:"col5" msg:"col5"`

	Col6 *fvec.VMStrTPStrStr `json:"col6" cql:"col6" msg:"col6"`

	Col7 *fvec.VLInt `json:"col7" cql:"col7" msg:"col7"`

	Col8 *fvec.ByteType `json:"col8" cql:"col8" msg:"col8"`

	Col9 *fvec.VSStr `json:"col9" cql:"col9" msg:"col9"`

	Col10 *fvec.VMStrDbl `json:"col10" cql:"col10" msg:"col10"`

	Col11 *fvec.CounterType `json:"col11" cql:"col11" msg:"col11"`

	Col12 *fvec.VSIntDbl `json:"col12" cql:"col12" msg:"col12"`


}

// NewGenTT a new object
func NewGenTT() *GenTT{
	n := new(GenTT)
	n.Name = new(fvec.VName)
	
	n.Col1 = new(fvec.StringType)
	
	n.Col2 = new(fvec.VMStrTPStrInt)
	
	n.Col3 = new(fvec.CounterType)
	
	n.Col4 = new(fvec.DoubleType)
	
	n.Col5 = new(fvec.VSInt)
	
	n.Col6 = new(fvec.VMStrTPStrStr)
	
	n.Col7 = new(fvec.VLInt)
	
	n.Col8 = new(fvec.ByteType)
	
	n.Col9 = new(fvec.VSStr)
	
	n.Col10 = new(fvec.VMStrDbl)
	
	n.Col11 = new(fvec.CounterType)
	
	n.Col12 = new(fvec.VSIntDbl)
	
	return n
}

// DBColumns list of non counter db columns as strings
func (f *GenTT) DBColumns() []string {
	return []string{
	
		
		"col1",
		
	
		
		"col2",
		
	
		
		
	
		
		"col4",
		
	
		
		"col5",
		
	
		
		"col6",
		
	
		
		"col7",
		
	
		
		"col8",
		
	
		
		"col9",
		
	
		
		"col10",
		
	
		
		
	
		
		"col12",
		
	
	}
}


// DBCounterColumns list of db columns as strings that are counters
func (f *GenTT) DBCounterColumns() []string {
	return []string{
	
		
	
		
	
		
		"col3",
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
		"col11",
		
	
		
	
	}
}

// TypeStrings list of the column types as strings
func (f *GenTT) TypeStrings() []string {
	return []string{
	
		"StringType",
	
		"VMStrTPStrInt",
	
		"CounterType",
	
		"DoubleType",
	
		"VSInt",
	
		"VMStrTPStrStr",
	
		"VLInt",
	
		"ByteType",
	
		"VSStr",
	
		"VMStrDbl",
	
		"CounterType",
	
		"VSIntDbl",
	
	}
}

// VarNameStrings the class fields as strings
func (f *GenTT) VarNameStrings() []string {
	return []string{
	
		"Col1",
	
		"Col2",
	
		"Col3",
	
		"Col4",
	
		"Col5",
	
		"Col6",
	
		"Col7",
	
		"Col8",
	
		"Col9",
	
		"Col10",
	
		"Col11",
	
		"Col12",
	
	}
}

// CassandraCreateStatement the list of cassandra create the table statement
// if there are counters in the mix, then there will be another table {table}_counters
// cassandra only allows counters in a table to itself aside from the primary key
func (f *GenTT) CassandraCreateStatement(keyspace string, table string) []string {

	queries := []string{}
	subs := []string{
		"uid ascii",
		"slab ascii",
		"ord ascii",
	}
	cSubs := []string{
		"uid ascii",
		"slab ascii",
		"ord ascii",
	}
	haveC := false
	haveA := false
	
	if len(f.Col1.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col1.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col1 " + f.Col1.CassandraType())
	haveA = true
	
	
	if len(f.Col2.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col2.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col2 " + f.Col2.CassandraType())
	haveA = true
	
	
	if len(f.Col3.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col3.CassandraCreateType(keyspace))
	}
	
	cSubs = append(cSubs, "col3 " + f.Col3.CassandraType())
	haveC = true
	
	
	if len(f.Col4.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col4.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col4 " + f.Col4.CassandraType())
	haveA = true
	
	
	if len(f.Col5.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col5.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col5 " + f.Col5.CassandraType())
	haveA = true
	
	
	if len(f.Col6.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col6.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col6 " + f.Col6.CassandraType())
	haveA = true
	
	
	if len(f.Col7.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col7.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col7 " + f.Col7.CassandraType())
	haveA = true
	
	
	if len(f.Col8.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col8.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col8 " + f.Col8.CassandraType())
	haveA = true
	
	
	if len(f.Col9.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col9.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col9 " + f.Col9.CassandraType())
	haveA = true
	
	
	if len(f.Col10.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col10.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col10 " + f.Col10.CassandraType())
	haveA = true
	
	
	if len(f.Col11.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col11.CassandraCreateType(keyspace))
	}
	
	cSubs = append(cSubs, "col11 " + f.Col11.CassandraType())
	haveC = true
	
	
	if len(f.Col12.CassandraCreateType(keyspace)) > 0{
		queries = append(queries, f.Col12.CassandraCreateType(keyspace))
	}
	
	subs = append(subs, "col12 " + f.Col12.CassandraType())
	haveA = true
	
	

	createSQL := "CREATE TABLE IF NOT EXISTS " + keyspace + "." + table + "("
	createSQL += strings.Join(subs, ", ")
	createSQL += `
		, PRIMARY KEY ((uid, slab), ord)
		) WITH CLUSTERING ORDER BY (ord ASC) AND
		compaction = {
		'class': 'TimeWindowCompactionStrategy',
		'compaction_window_unit': 'DAYS',
		'compaction_window_size': '1'
		}
		AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'};
	`

	counterSQL := "CREATE TABLE IF NOT EXISTS " + keyspace + "." + table + "_counters("
	counterSQL += strings.Join(cSubs, ", ")
	counterSQL += `
		, PRIMARY KEY ((uid, slab), ord)
		) WITH compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy'}
		AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'};
	`

	if haveA{
		queries = append(queries, createSQL)
	}
	if haveC{
		queries = append(queries, counterSQL)
	}
	return queries
}

// CassandraSelectQueries the set of queries to get the full object
// this does not include a where clause just the SELECT (stuff, stuff, ...) FROM {table}
// if there are counters there will be 2 queries for the counters table
func (f *GenTT) CassandraSelectQueries(table string) []string {
	return []string{
		"SELECT " + strings.Join(f.DBColumns(), ",") + " FROM " + table,
		
		"SELECT " + strings.Join(f.DBCounterColumns(), ",") + " FROM " + table,
		
	}
}

// GetName return the name object
func (f *GenTT) GetName() *fvec.VName {
	return f.Name
}

// GetVectors get all the vectors as a list
func (f *GenTT) GetVectors() []fvec.Vector{
	return []fvec.Vector{
	
		
	
		
		f.Col2,
		
	
		
	
		
	
		
		f.Col5,
		
	
		
		f.Col6,
		
	
		
		f.Col7,
		
	
		
	
		
		f.Col9,
		
	
		
		f.Col10,
		
	
		
	
		
		f.Col12,
		
	
	}
}

// GetScalars get all the scalars as a list
func (f *GenTT) GetScalars() []fvec.Scalar{
	return []fvec.Scalar{
	
		
		f.Col1,
		
	
		
	
		
		f.Col3,
		
	
		
		f.Col4,
		
	
		
	
		
	
		
	
		
		f.Col8,
		
	
		
	
		
	
		
		f.Col11,
		
	
		
	
	}
}


// GetCounters get all the counters as a list
func (f *GenTT) GetCounters() []fvec.Scalar{
	return []fvec.Scalar{
	
		
	
		
	
		
		f.Col3,
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
		f.Col11,
		
	
		
	
	}
}

// Key key name
func (f *GenTT) Key() string{
	return f.Name.Key
}


// UniqueId unique id of the vector
func (f *GenTT) UniqueId() uint64{
	return f.Name.UniqueId()
}

// UniqueIdString unique id as a base36 string of the vector
func (f *GenTT) UniqueIdString() string{
	return f.Name.UniqueIdString()
}
