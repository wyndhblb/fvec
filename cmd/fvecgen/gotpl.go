// The GoLang template for generation of go based objects

package main

var GOLANG_TEMPLATE string = `
// Auto generated by fvecgen on %s
// Edit at your own risk
//

package {{.PackageName}}

import (
	"github.com/wyndhblb/fvec"
	"strings"
)

type {{.ClassName}} struct {
	Name *fvec.VName
{{ range .Fields }}
	{{.FieldName}} fvec.{{.FieldType}} ` + "`" + `json:"{{.ColumnName}}" cql:"{{.ColumnName}}" msg:"{{.ColumnName}}"` + "`" + `
{{ end }}

}

// New{{.ClassName}} a new object
func New{{.ClassName}}() *{{.ClassName}}{
	n := new({{.ClassName}})
	n.Name = new(fvec.VName)
	return n
}

// DBColumns list of non counter db columns as strings
func (f *{{.ClassName}}) DBColumns() []string {
	return []string{
	{{ range .Fields }}
		{{ if .IsCounter }}
		{{ else }}
		"{{ .ColumnName }}",
		{{ end }}
	{{ end }}
	}
}


// DBCounterColumns list of db columns as strings that are counters
func (f *{{.ClassName}}) DBCounterColumns() []string {
	return []string{
	{{ range .Fields }}
		{{ if .IsCounter }}
		"{{ .ColumnName }}",
		{{ end }}
	{{ end }}
	}
}

// TypeStrings list of the column types as strings
func (f *{{.ClassName}}) TypeStrings() []string {
	return []string{
	{{ range .Fields }}
		"{{ .FieldType }}",
	{{ end }}
	}
}

// VarNameStrings the class fields as strings
func (f *{{.ClassName}}) VarNameStrings() []string {
	return []string{
	{{ range .Fields }}
		"{{ .FieldName }}",
	{{ end }}
	}
}

// CassandraCreateStatement the list of cassandra create the table statement
// if there are counters in the mix, then there will be another table {table}_counters
// cassandra only allows counters in a table to itself aside from the primary key
func (f *{{.ClassName}}) CassandraCreateStatement(keyspace string, table string) []string {

	queries := []string{}
	subs := []string{
		"uid ascii",
		"slab ascii",
		"ord ascii",
	}
	cSubs := []string{
		"uid ascii",
		"slab ascii",
		"ord ascii",
	}
	haveC := false
	haveA := false
	{{ range .Fields }}
	if len(f.{{.FieldName}}.CassandraCreateType()) > 0{
		queries = append(queries, f.{{.FieldName}}.CassandraCreateType())
	}
	{{ if .IsCounter }}
	cSubs = append(subs, "{{.ColumnName}} " + f.{{.FieldName}}.CassandraType())
	haveC = true
	{{ else }}
	subs = append(subs, "{{.ColumnName}} " + f.{{.FieldName}}.CassandraType())
	haveA = true
	{{ end }}
	{{ end }}

	createSQL := "CREATE TABLE IF NOT EXISTS " + keyspace + "." + table + "("
	createSQL += strings.Join(", ", subs)
	createSQL += ` + "`" + `
		PRIMARY KEY ((uid, slab), ord)
		) WITH CLUSTERING ORDER BY (ord ASC) AND
		compaction = {
		'class': 'TimeWindowCompactionStrategy',
		'compaction_window_unit': 'DAYS',
		'compaction_window_size': '1'
		}
		AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'};
	` + "`" + `

	counterSQL := "CREATE TABLE IF NOT EXISTS " + keyspace + "." + table + "_counters("
	counterSQL += strings.Join(", ", subs)
	counterSQL += ` + "`" + `
		PRIMARY KEY ((uid, slab), ord)
		) WITH compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy'}
		AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'};
	` + "`" + `

	if haveA{
		queries = append(queries, createSQL)
	}
	if haveC{
		queries = append(queries, counterSQL)
	}
	return queries
}

// GetName return the name object
func (f *{{.ClassName}}) GetName() *fvec.VName {
	return f.Name
}

// GetVectors get all the vectors as a list
func (f *{{.ClassName}}) GetVectors() []fvec.Vector{
	return []fvec.Vector{
	{{ range .Fields }}
		{{ if .IsVector }}
		f.{{.FieldName}},
		{{ end }}
	{{ end }}
	}
}

// GetScalars get all the scalars as a list
func (f *{{.ClassName}}) GetScalars() []fvec.Scalar{
	return []fvec.Scalar{
	{{ range .Fields }}
		{{ if .IsScalar }}
		f.{{.FieldName}},
		{{ end }}
	{{ end }}
	}
}


// GetCounters get all the counters as a list
func (f *{{.ClassName}}) GetCounters() []fvec.Scalar{
	return []fvec.Scalar{
	{{ range .Fields }}
		{{ if .IsCounter }}
		f.{{.FieldName}},
		{{ end }}
	{{ end }}
	}
}

// Key key name
func (f *{{.ClassName}}) Key() string{
	return f.Name.Key
}


// UniqueId unique id of the vector
func (f *{{.ClassName}}) UniqueId() uint64{
	return f.Name.UniqueId()
}

// UniqueIdString unique id as a base36 string of the vector
func (f *{{.ClassName}}) UniqueIdString() string{
	return f.Name.UniqueIdString()
}
`
