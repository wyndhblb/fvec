// Code generated by protoc-gen-gogo.
// source: vepr.proto
// DO NOT EDIT!

/*
	Package vepr is a generated protocol buffer package.

	It is generated from these files:
		vepr.proto

	It has these top-level messages:
		Tag
		VName
		VTDblDbl
		VTDblInt
		VTDblStr
		VTIntDbl
		VTIntInt
		VTIntStr
		VTStrDbl
		VTStrInt
		VTStrStr
		VLDbl
		VLInt
		VLStr
		VLDblDbl
		VLDblInt
		VLDblStr
		VLIntDbl
		VLIntInt
		VLIntStr
		VLStrDbl
		VLStrInt
		VLStrStr
		VSDbl
		VSInt
		VSStr
		VSDblDbl
		VSDblInt
		VSDblStr
		VSIntDbl
		VSIntInt
		VSIntStr
		VSStrDbl
		VSStrInt
		VSStrStr
		VMIntDbl
		VMIntInt
		VMIntStr
		VMStrDbl
		VMStrInt
		VMStrStr
		VMIntTPDblDbl
		VMIntTPDblInt
		VMIntTPDblStr
		VMIntTPIntDbl
		VMIntTPIntInt
		VMIntTPIntStr
		VMIntTPStrDbl
		VMIntTPStrInt
		VMIntTPStrStr
		VMStrTPDblDbl
		VMStrTPDblInt
		VMStrTPDblStr
		VMStrTPIntDbl
		VMStrTPIntInt
		VMStrTPIntStr
		VMStrTPStrDbl
		VMStrTPStrInt
		VMStrTPStrStr
*/
package vepr

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import github_com_wyndhblb_timeslab "github.com/wyndhblb/timeslab"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// easyjson:json
type Tag struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{0} }

// VN the base name for a given indexible element
// easyjson:json
type VName struct {
	// @inject_tag: cql:"key" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"key" msg:"key"`
	// @inject_tag: cql:"res" msg:"res"
	Resolution github_com_wyndhblb_timeslab.Resolution `protobuf:"varint,2,opt,name=resolution,proto3,enum=github.com.wyndhblb.timeslab.Resolution" json:"resolution,omitempty" cql:"res" msg:"res"`
	// @inject_tag: cql:"ttl" msg:"ttl"
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty" cql:"ttl" msg:"ttl"`
	// @inject_tag: cql:"-" msg:"-"
	XUniqueId uint64 `protobuf:"varint,4,opt,name=unique_id,json=uniqueId,proto3" json:"-" cql:"-" msg:"-"`
	// @inject_tag: cql:"uid" msg:"uid"
	XUniqueStr string `protobuf:"bytes,5,opt,name=unique_str,json=uniqueStr,proto3" json:"-" cql:"uid" msg:"uid"`
	// @inject_tag: cql:"tags" msg:"tags"
	Tags []*Tag `protobuf:"bytes,11,rep,name=tags" json:"tags,omitempty" cql:"tags" msg:"tags"`
}

func (m *VName) Reset()                    { *m = VName{} }
func (m *VName) String() string            { return proto.CompactTextString(m) }
func (*VName) ProtoMessage()               {}
func (*VName) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{1} }

// VTDblDbl Tuple Type key=double value=double
// easyjson:json
type VTDblDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblDbl) Reset()                    { *m = VTDblDbl{} }
func (m *VTDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VTDblDbl) ProtoMessage()               {}
func (*VTDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{2} }

// VTDblInt Tuple Type key=double value=int64
// easyjson:json
type VTDblInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblInt) Reset()                    { *m = VTDblInt{} }
func (m *VTDblInt) String() string            { return proto.CompactTextString(m) }
func (*VTDblInt) ProtoMessage()               {}
func (*VTDblInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{3} }

// VTDblStr Tuple Type key=double value=string
// easyjson:json
type VTDblStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblStr) Reset()                    { *m = VTDblStr{} }
func (m *VTDblStr) String() string            { return proto.CompactTextString(m) }
func (*VTDblStr) ProtoMessage()               {}
func (*VTDblStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{4} }

// VTIntDbl Tuple Type key=int64 value=double
// easyjson:json
type VTIntDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntDbl) Reset()                    { *m = VTIntDbl{} }
func (m *VTIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VTIntDbl) ProtoMessage()               {}
func (*VTIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{5} }

// VTIntInt Tuple Type key=int64 value=int64
// easyjson:json
type VTIntInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntInt) Reset()                    { *m = VTIntInt{} }
func (m *VTIntInt) String() string            { return proto.CompactTextString(m) }
func (*VTIntInt) ProtoMessage()               {}
func (*VTIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{6} }

// VTIntStr Tuple Type key=int64 value=string
// easyjson:json
type VTIntStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntStr) Reset()                    { *m = VTIntStr{} }
func (m *VTIntStr) String() string            { return proto.CompactTextString(m) }
func (*VTIntStr) ProtoMessage()               {}
func (*VTIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{7} }

// VTStrDbl Tuple Type key=string value=double
// easyjson:json
type VTStrDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrDbl) Reset()                    { *m = VTStrDbl{} }
func (m *VTStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VTStrDbl) ProtoMessage()               {}
func (*VTStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{8} }

// VTStrInt Tuple Type key=string value=int64
// easyjson:json
type VTStrInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrInt) Reset()                    { *m = VTStrInt{} }
func (m *VTStrInt) String() string            { return proto.CompactTextString(m) }
func (*VTStrInt) ProtoMessage()               {}
func (*VTStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{9} }

// VTStrStr Tuple Type key=string value=string
// easyjson:json
type VTStrStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrStr) Reset()                    { *m = VTStrStr{} }
func (m *VTStrStr) String() string            { return proto.CompactTextString(m) }
func (*VTStrStr) ProtoMessage()               {}
func (*VTStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{10} }

// VLDbl list
// easyjson:json
type VLDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []float64 `protobuf:"fixed64,2,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDbl) Reset()                    { *m = VLDbl{} }
func (m *VLDbl) String() string            { return proto.CompactTextString(m) }
func (*VLDbl) ProtoMessage()               {}
func (*VLDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{11} }

// VLInt list
// easyjson:json
type VLInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []int64 `protobuf:"varint,2,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLInt) Reset()                    { *m = VLInt{} }
func (m *VLInt) String() string            { return proto.CompactTextString(m) }
func (*VLInt) ProtoMessage()               {}
func (*VLInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{12} }

// VLStr list
// easyjson:json
type VLStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []string `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStr) Reset()                    { *m = VLStr{} }
func (m *VLStr) String() string            { return proto.CompactTextString(m) }
func (*VLStr) ProtoMessage()               {}
func (*VLStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{13} }

// VLDblDbl list
// easyjson:json
type VLDblDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblDbl) Reset()                    { *m = VLDblDbl{} }
func (m *VLDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VLDblDbl) ProtoMessage()               {}
func (*VLDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{14} }

// VLDblInt list
// easyjson:json
type VLDblInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblInt) Reset()                    { *m = VLDblInt{} }
func (m *VLDblInt) String() string            { return proto.CompactTextString(m) }
func (*VLDblInt) ProtoMessage()               {}
func (*VLDblInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{15} }

// VLDblStr list
// easyjson:json
type VLDblStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblStr) Reset()                    { *m = VLDblStr{} }
func (m *VLDblStr) String() string            { return proto.CompactTextString(m) }
func (*VLDblStr) ProtoMessage()               {}
func (*VLDblStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{16} }

// VLIntDbl list
// easyjson:json
type VLIntDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntDbl) Reset()                    { *m = VLIntDbl{} }
func (m *VLIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VLIntDbl) ProtoMessage()               {}
func (*VLIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{17} }

// VLIntInt list
// easyjson:json
type VLIntInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntInt) Reset()                    { *m = VLIntInt{} }
func (m *VLIntInt) String() string            { return proto.CompactTextString(m) }
func (*VLIntInt) ProtoMessage()               {}
func (*VLIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{18} }

// VLIntStr list
// easyjson:json
type VLIntStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntStr) Reset()                    { *m = VLIntStr{} }
func (m *VLIntStr) String() string            { return proto.CompactTextString(m) }
func (*VLIntStr) ProtoMessage()               {}
func (*VLIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{19} }

// VLStrDbl list
// easyjson:json
type VLStrDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrDbl) Reset()                    { *m = VLStrDbl{} }
func (m *VLStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VLStrDbl) ProtoMessage()               {}
func (*VLStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{20} }

// VLStrInt list
// easyjson:json
type VLStrInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrInt) Reset()                    { *m = VLStrInt{} }
func (m *VLStrInt) String() string            { return proto.CompactTextString(m) }
func (*VLStrInt) ProtoMessage()               {}
func (*VLStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{21} }

// VLStrStr list
// easyjson:json
type VLStrStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrStr) Reset()                    { *m = VLStrStr{} }
func (m *VLStrStr) String() string            { return proto.CompactTextString(m) }
func (*VLStrStr) ProtoMessage()               {}
func (*VLStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{22} }

// VSDbl set
// easyjson:json
type VSDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []float64 `protobuf:"fixed64,2,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDbl) Reset()                    { *m = VSDbl{} }
func (m *VSDbl) String() string            { return proto.CompactTextString(m) }
func (*VSDbl) ProtoMessage()               {}
func (*VSDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{23} }

// VSInt set
// easyjson:json
type VSInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []int64 `protobuf:"varint,2,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSInt) Reset()                    { *m = VSInt{} }
func (m *VSInt) String() string            { return proto.CompactTextString(m) }
func (*VSInt) ProtoMessage()               {}
func (*VSInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{24} }

// VSStr set
// easyjson:json
type VSStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []string `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStr) Reset()                    { *m = VSStr{} }
func (m *VSStr) String() string            { return proto.CompactTextString(m) }
func (*VSStr) ProtoMessage()               {}
func (*VSStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{25} }

// VSDblDbl set
// easyjson:json
type VSDblDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblDbl) Reset()                    { *m = VSDblDbl{} }
func (m *VSDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VSDblDbl) ProtoMessage()               {}
func (*VSDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{26} }

// VSDblInt set
// easyjson:json
type VSDblInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblInt) Reset()                    { *m = VSDblInt{} }
func (m *VSDblInt) String() string            { return proto.CompactTextString(m) }
func (*VSDblInt) ProtoMessage()               {}
func (*VSDblInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{27} }

// VSDblStr set
// easyjson:json
type VSDblStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblStr) Reset()                    { *m = VSDblStr{} }
func (m *VSDblStr) String() string            { return proto.CompactTextString(m) }
func (*VSDblStr) ProtoMessage()               {}
func (*VSDblStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{28} }

// VSIntDbl set
// easyjson:json
type VSIntDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntDbl) Reset()                    { *m = VSIntDbl{} }
func (m *VSIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VSIntDbl) ProtoMessage()               {}
func (*VSIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{29} }

// VSIntInt set
// easyjson:json
type VSIntInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntInt) Reset()                    { *m = VSIntInt{} }
func (m *VSIntInt) String() string            { return proto.CompactTextString(m) }
func (*VSIntInt) ProtoMessage()               {}
func (*VSIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{30} }

// VSIntStr set
// easyjson:json
type VSIntStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntStr) Reset()                    { *m = VSIntStr{} }
func (m *VSIntStr) String() string            { return proto.CompactTextString(m) }
func (*VSIntStr) ProtoMessage()               {}
func (*VSIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{31} }

// VSStrDbl set
// easyjson:json
type VSStrDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrDbl) Reset()                    { *m = VSStrDbl{} }
func (m *VSStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VSStrDbl) ProtoMessage()               {}
func (*VSStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{32} }

// VSStrInt set
// easyjson:json
type VSStrInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrInt) Reset()                    { *m = VSStrInt{} }
func (m *VSStrInt) String() string            { return proto.CompactTextString(m) }
func (*VSStrInt) ProtoMessage()               {}
func (*VSStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{33} }

// VSStrStr set
// easyjson:json
type VSStrStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrStr) Reset()                    { *m = VSStrStr{} }
func (m *VSStrStr) String() string            { return proto.CompactTextString(m) }
func (*VSStrStr) ProtoMessage()               {}
func (*VSStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{34} }

type VMIntDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[int64]float64 `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMIntDbl) Reset()                    { *m = VMIntDbl{} }
func (m *VMIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntDbl) ProtoMessage()               {}
func (*VMIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{35} }

type VMIntInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[int64]int64 `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMIntInt) Reset()                    { *m = VMIntInt{} }
func (m *VMIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntInt) ProtoMessage()               {}
func (*VMIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{36} }

type VMIntStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[int64]string `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMIntStr) Reset()                    { *m = VMIntStr{} }
func (m *VMIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntStr) ProtoMessage()               {}
func (*VMIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{37} }

// VMStrDbl map of string -> double
// easyjson:json
type VMStrDbl struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]float64 `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrDbl) Reset()                    { *m = VMStrDbl{} }
func (m *VMStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrDbl) ProtoMessage()               {}
func (*VMStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{38} }

// VMStrInt map of string -> int64
// easyjson:json
type VMStrInt struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]int64 `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrInt) Reset()                    { *m = VMStrInt{} }
func (m *VMStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrInt) ProtoMessage()               {}
func (*VMStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{39} }

// VMStrStr map of string -> string
// easyjson:json
type VMStrStr struct {
	// @inject_tag: cql:"name" msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name" msg:"name"`
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]string `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrStr) Reset()                    { *m = VMStrStr{} }
func (m *VMStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrStr) ProtoMessage()               {}
func (*VMStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{40} }

type VMIntTPDblDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTDblDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPDblDbl) Reset()                    { *m = VMIntTPDblDbl{} }
func (m *VMIntTPDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblDbl) ProtoMessage()               {}
func (*VMIntTPDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{41} }

type VMIntTPDblInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTDblInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPDblInt) Reset()                    { *m = VMIntTPDblInt{} }
func (m *VMIntTPDblInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblInt) ProtoMessage()               {}
func (*VMIntTPDblInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{42} }

type VMIntTPDblStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTDblStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPDblStr) Reset()                    { *m = VMIntTPDblStr{} }
func (m *VMIntTPDblStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblStr) ProtoMessage()               {}
func (*VMIntTPDblStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{43} }

type VMIntTPIntDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTIntDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPIntDbl) Reset()                    { *m = VMIntTPIntDbl{} }
func (m *VMIntTPIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntDbl) ProtoMessage()               {}
func (*VMIntTPIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{44} }

type VMIntTPIntInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTIntInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPIntInt) Reset()                    { *m = VMIntTPIntInt{} }
func (m *VMIntTPIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntInt) ProtoMessage()               {}
func (*VMIntTPIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{45} }

type VMIntTPIntStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTIntStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPIntStr) Reset()                    { *m = VMIntTPIntStr{} }
func (m *VMIntTPIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntStr) ProtoMessage()               {}
func (*VMIntTPIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{46} }

type VMIntTPStrDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTStrDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPStrDbl) Reset()                    { *m = VMIntTPStrDbl{} }
func (m *VMIntTPStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrDbl) ProtoMessage()               {}
func (*VMIntTPStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{47} }

type VMIntTPStrInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTStrInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPStrInt) Reset()                    { *m = VMIntTPStrInt{} }
func (m *VMIntTPStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrInt) ProtoMessage()               {}
func (*VMIntTPStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{48} }

type VMIntTPStrStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[int64]*VTStrStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMIntTPStrStr) Reset()                    { *m = VMIntTPStrStr{} }
func (m *VMIntTPStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrStr) ProtoMessage()               {}
func (*VMIntTPStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{49} }

// VMStrTPDblDbl map of double -> set(double, double)
// easyjson:json
type VMStrTPDblDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTDblDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPDblDbl) Reset()                    { *m = VMStrTPDblDbl{} }
func (m *VMStrTPDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblDbl) ProtoMessage()               {}
func (*VMStrTPDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{50} }

// VMStrTPDblInt map of double -> set(double, int64)
// easyjson:json
type VMStrTPDblInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTDblInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPDblInt) Reset()                    { *m = VMStrTPDblInt{} }
func (m *VMStrTPDblInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblInt) ProtoMessage()               {}
func (*VMStrTPDblInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{51} }

// VMStrTPDblStr map of double -> set(double, string)
// easyjson:json
type VMStrTPDblStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTDblStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPDblStr) Reset()                    { *m = VMStrTPDblStr{} }
func (m *VMStrTPDblStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblStr) ProtoMessage()               {}
func (*VMStrTPDblStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{52} }

// VMStrTPIntDbl map of int64 -> set(int64, double)
// easyjson:json
type VMStrTPIntDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTIntDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPIntDbl) Reset()                    { *m = VMStrTPIntDbl{} }
func (m *VMStrTPIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntDbl) ProtoMessage()               {}
func (*VMStrTPIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{53} }

// VMStrTPIntInt map of int64 -> set(int64, int64)
// easyjson:json
type VMStrTPIntInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTIntInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPIntInt) Reset()                    { *m = VMStrTPIntInt{} }
func (m *VMStrTPIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntInt) ProtoMessage()               {}
func (*VMStrTPIntInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{54} }

// VMStrTPIntStr map of int64 -> set(int64, string)
// easyjson:json
type VMStrTPIntStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTIntStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPIntStr) Reset()                    { *m = VMStrTPIntStr{} }
func (m *VMStrTPIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntStr) ProtoMessage()               {}
func (*VMStrTPIntStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{55} }

// VMStrTPStrDbl map of string -> set(string, double)
// easyjson:json
type VMStrTPStrDbl struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTStrDbl `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPStrDbl) Reset()                    { *m = VMStrTPStrDbl{} }
func (m *VMStrTPStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrDbl) ProtoMessage()               {}
func (*VMStrTPStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{56} }

// VMStrTPStrInt map of string -> set(string, int64)
// easyjson:json
type VMStrTPStrInt struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTStrInt `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPStrInt) Reset()                    { *m = VMStrTPStrInt{} }
func (m *VMStrTPStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrInt) ProtoMessage()               {}
func (*VMStrTPStrInt) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{57} }

// VMStrTPStrStr map of string -> set(string, string)
// easyjson:json
type VMStrTPStrStr struct {
	// @inject_tag: cql:"name", msg:"name"
	Name *VName `protobuf:"bytes,1,opt,name=name" json:"name,omitempty" cql:"name", msg:"name"`
	// @inject_tag: cql:"vec", msg:"vec"
	Vec map[string]*VTStrStr `protobuf:"bytes,2,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec", msg:"vec"`
}

func (m *VMStrTPStrStr) Reset()                    { *m = VMStrTPStrStr{} }
func (m *VMStrTPStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrStr) ProtoMessage()               {}
func (*VMStrTPStrStr) Descriptor() ([]byte, []int) { return fileDescriptorVepr, []int{58} }

func init() {
	proto.RegisterType((*Tag)(nil), "github.com.wyndhblb.fvec.Tag")
	proto.RegisterType((*VName)(nil), "github.com.wyndhblb.fvec.VName")
	proto.RegisterType((*VTDblDbl)(nil), "github.com.wyndhblb.fvec.VTDblDbl")
	proto.RegisterType((*VTDblInt)(nil), "github.com.wyndhblb.fvec.VTDblInt")
	proto.RegisterType((*VTDblStr)(nil), "github.com.wyndhblb.fvec.VTDblStr")
	proto.RegisterType((*VTIntDbl)(nil), "github.com.wyndhblb.fvec.VTIntDbl")
	proto.RegisterType((*VTIntInt)(nil), "github.com.wyndhblb.fvec.VTIntInt")
	proto.RegisterType((*VTIntStr)(nil), "github.com.wyndhblb.fvec.VTIntStr")
	proto.RegisterType((*VTStrDbl)(nil), "github.com.wyndhblb.fvec.VTStrDbl")
	proto.RegisterType((*VTStrInt)(nil), "github.com.wyndhblb.fvec.VTStrInt")
	proto.RegisterType((*VTStrStr)(nil), "github.com.wyndhblb.fvec.VTStrStr")
	proto.RegisterType((*VLDbl)(nil), "github.com.wyndhblb.fvec.VLDbl")
	proto.RegisterType((*VLInt)(nil), "github.com.wyndhblb.fvec.VLInt")
	proto.RegisterType((*VLStr)(nil), "github.com.wyndhblb.fvec.VLStr")
	proto.RegisterType((*VLDblDbl)(nil), "github.com.wyndhblb.fvec.VLDblDbl")
	proto.RegisterType((*VLDblInt)(nil), "github.com.wyndhblb.fvec.VLDblInt")
	proto.RegisterType((*VLDblStr)(nil), "github.com.wyndhblb.fvec.VLDblStr")
	proto.RegisterType((*VLIntDbl)(nil), "github.com.wyndhblb.fvec.VLIntDbl")
	proto.RegisterType((*VLIntInt)(nil), "github.com.wyndhblb.fvec.VLIntInt")
	proto.RegisterType((*VLIntStr)(nil), "github.com.wyndhblb.fvec.VLIntStr")
	proto.RegisterType((*VLStrDbl)(nil), "github.com.wyndhblb.fvec.VLStrDbl")
	proto.RegisterType((*VLStrInt)(nil), "github.com.wyndhblb.fvec.VLStrInt")
	proto.RegisterType((*VLStrStr)(nil), "github.com.wyndhblb.fvec.VLStrStr")
	proto.RegisterType((*VSDbl)(nil), "github.com.wyndhblb.fvec.VSDbl")
	proto.RegisterType((*VSInt)(nil), "github.com.wyndhblb.fvec.VSInt")
	proto.RegisterType((*VSStr)(nil), "github.com.wyndhblb.fvec.VSStr")
	proto.RegisterType((*VSDblDbl)(nil), "github.com.wyndhblb.fvec.VSDblDbl")
	proto.RegisterType((*VSDblInt)(nil), "github.com.wyndhblb.fvec.VSDblInt")
	proto.RegisterType((*VSDblStr)(nil), "github.com.wyndhblb.fvec.VSDblStr")
	proto.RegisterType((*VSIntDbl)(nil), "github.com.wyndhblb.fvec.VSIntDbl")
	proto.RegisterType((*VSIntInt)(nil), "github.com.wyndhblb.fvec.VSIntInt")
	proto.RegisterType((*VSIntStr)(nil), "github.com.wyndhblb.fvec.VSIntStr")
	proto.RegisterType((*VSStrDbl)(nil), "github.com.wyndhblb.fvec.VSStrDbl")
	proto.RegisterType((*VSStrInt)(nil), "github.com.wyndhblb.fvec.VSStrInt")
	proto.RegisterType((*VSStrStr)(nil), "github.com.wyndhblb.fvec.VSStrStr")
	proto.RegisterType((*VMIntDbl)(nil), "github.com.wyndhblb.fvec.VMIntDbl")
	proto.RegisterType((*VMIntInt)(nil), "github.com.wyndhblb.fvec.VMIntInt")
	proto.RegisterType((*VMIntStr)(nil), "github.com.wyndhblb.fvec.VMIntStr")
	proto.RegisterType((*VMStrDbl)(nil), "github.com.wyndhblb.fvec.VMStrDbl")
	proto.RegisterType((*VMStrInt)(nil), "github.com.wyndhblb.fvec.VMStrInt")
	proto.RegisterType((*VMStrStr)(nil), "github.com.wyndhblb.fvec.VMStrStr")
	proto.RegisterType((*VMIntTPDblDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPDblDbl")
	proto.RegisterType((*VMIntTPDblInt)(nil), "github.com.wyndhblb.fvec.VMIntTPDblInt")
	proto.RegisterType((*VMIntTPDblStr)(nil), "github.com.wyndhblb.fvec.VMIntTPDblStr")
	proto.RegisterType((*VMIntTPIntDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPIntDbl")
	proto.RegisterType((*VMIntTPIntInt)(nil), "github.com.wyndhblb.fvec.VMIntTPIntInt")
	proto.RegisterType((*VMIntTPIntStr)(nil), "github.com.wyndhblb.fvec.VMIntTPIntStr")
	proto.RegisterType((*VMIntTPStrDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPStrDbl")
	proto.RegisterType((*VMIntTPStrInt)(nil), "github.com.wyndhblb.fvec.VMIntTPStrInt")
	proto.RegisterType((*VMIntTPStrStr)(nil), "github.com.wyndhblb.fvec.VMIntTPStrStr")
	proto.RegisterType((*VMStrTPDblDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPDblDbl")
	proto.RegisterType((*VMStrTPDblInt)(nil), "github.com.wyndhblb.fvec.VMStrTPDblInt")
	proto.RegisterType((*VMStrTPDblStr)(nil), "github.com.wyndhblb.fvec.VMStrTPDblStr")
	proto.RegisterType((*VMStrTPIntDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPIntDbl")
	proto.RegisterType((*VMStrTPIntInt)(nil), "github.com.wyndhblb.fvec.VMStrTPIntInt")
	proto.RegisterType((*VMStrTPIntStr)(nil), "github.com.wyndhblb.fvec.VMStrTPIntStr")
	proto.RegisterType((*VMStrTPStrDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPStrDbl")
	proto.RegisterType((*VMStrTPStrInt)(nil), "github.com.wyndhblb.fvec.VMStrTPStrInt")
	proto.RegisterType((*VMStrTPStrStr)(nil), "github.com.wyndhblb.fvec.VMStrTPStrStr")
}
func (m *Tag) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Tag) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VName) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VName) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Resolution != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVepr(data, i, uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintVepr(data, i, uint64(m.Ttl))
	}
	if m.XUniqueId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintVepr(data, i, uint64(m.XUniqueId))
	}
	if len(m.XUniqueStr) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.XUniqueStr)))
		i += copy(data[i:], m.XUniqueStr)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x5a
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VTDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVepr(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VTDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VTIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintVepr(data, i, uint64(m.Key))
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintVepr(data, i, uint64(m.Key))
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVepr(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VTIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintVepr(data, i, uint64(m.Key))
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VTStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVepr(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VTStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VLDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n1, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Vec) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Vec)*8))
		for _, num := range m.Vec {
			f2 := math.Float64bits(float64(num))
			data[i] = uint8(f2)
			i++
			data[i] = uint8(f2 >> 8)
			i++
			data[i] = uint8(f2 >> 16)
			i++
			data[i] = uint8(f2 >> 24)
			i++
			data[i] = uint8(f2 >> 32)
			i++
			data[i] = uint8(f2 >> 40)
			i++
			data[i] = uint8(f2 >> 48)
			i++
			data[i] = uint8(f2 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *VLInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n3, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Vec) > 0 {
		data5 := make([]byte, len(m.Vec)*10)
		var j4 int
		for _, num1 := range m.Vec {
			num := uint64(num1)
			for num >= 1<<7 {
				data5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			data5[j4] = uint8(num)
			j4++
		}
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(j4))
		i += copy(data[i:], data5[:j4])
	}
	return i, nil
}

func (m *VLStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n6, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VLDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n7, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n8, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n9, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n10, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n11, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n12, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n13, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n14, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n15, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n16, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Vec) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(len(m.Vec)*8))
		for _, num := range m.Vec {
			f17 := math.Float64bits(float64(num))
			data[i] = uint8(f17)
			i++
			data[i] = uint8(f17 >> 8)
			i++
			data[i] = uint8(f17 >> 16)
			i++
			data[i] = uint8(f17 >> 24)
			i++
			data[i] = uint8(f17 >> 32)
			i++
			data[i] = uint8(f17 >> 40)
			i++
			data[i] = uint8(f17 >> 48)
			i++
			data[i] = uint8(f17 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *VSInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n18, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Vec) > 0 {
		data20 := make([]byte, len(m.Vec)*10)
		var j19 int
		for _, num1 := range m.Vec {
			num := uint64(num1)
			for num >= 1<<7 {
				data20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			data20[j19] = uint8(num)
			j19++
		}
		data[i] = 0x12
		i++
		i = encodeVarintVepr(data, i, uint64(j19))
		i += copy(data[i:], data20[:j19])
	}
	return i, nil
}

func (m *VSStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n21, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VSDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n22, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n23, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n24, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n25, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n26, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n27, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n28, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n29, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n30, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VMIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n31, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + sovVepr(uint64(k)) + 1 + 8
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			data[i] = 0x11
			i++
			i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *VMIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n32, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + sovVepr(uint64(k)) + 1 + sovVepr(uint64(v))
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintVepr(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *VMIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n33, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + sovVepr(uint64(k)) + 1 + len(v) + sovVepr(uint64(len(v)))
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *VMStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n34, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + 8
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x11
			i++
			i = encodeFixed64Vepr(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *VMStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n35, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + sovVepr(uint64(v))
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintVepr(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *VMStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n36, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + len(v) + sovVepr(uint64(len(v)))
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintVepr(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *VMIntTPDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n37, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n38, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n38
			}
		}
	}
	return i, nil
}

func (m *VMIntTPDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n39, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n40, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n40
			}
		}
	}
	return i, nil
}

func (m *VMIntTPDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n41, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n42, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n42
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n43, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n44, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n44
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n45, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n46, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n46
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n47, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n48, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n48
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n49, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n50, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n50
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n51, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n52, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n52
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n53, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + sovVepr(uint64(k)) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintVepr(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n54, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n54
			}
		}
	}
	return i, nil
}

func (m *VMStrTPDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n55, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n56, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n56
			}
		}
	}
	return i, nil
}

func (m *VMStrTPDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n57, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n58, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n58
			}
		}
	}
	return i, nil
}

func (m *VMStrTPDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n59, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n60, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n60
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n61, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n62, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n62
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n63, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n64, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n64
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n65, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n66, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n66
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n67, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n68, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n68
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n69, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n70, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n70
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintVepr(data, i, uint64(m.Name.Size()))
		n71, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0x12
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVepr(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVepr(uint64(len(k))) + msgSize
			i = encodeVarintVepr(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintVepr(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintVepr(data, i, uint64(v.Size()))
				n72, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n72
			}
		}
	}
	return i, nil
}

func encodeFixed64Vepr(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Vepr(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVepr(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTag(r randyVepr, easy bool) *Tag {
	this := &Tag{}
	this.Name = randStringVepr(r)
	this.Value = randStringVepr(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVName(r randyVepr, easy bool) *VName {
	this := &VName{}
	this.Key = randStringVepr(r)
	this.Resolution = github_com_wyndhblb_timeslab.Resolution([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}[r.Intn(15)])
	this.Ttl = uint32(r.Uint32())
	this.XUniqueId = uint64(uint64(r.Uint32()))
	this.XUniqueStr = randStringVepr(r)
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Tags = make([]*Tag, v1)
		for i := 0; i < v1; i++ {
			this.Tags[i] = NewPopulatedTag(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblDbl(r randyVepr, easy bool) *VTDblDbl {
	this := &VTDblDbl{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblInt(r randyVepr, easy bool) *VTDblInt {
	this := &VTDblInt{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblStr(r randyVepr, easy bool) *VTDblStr {
	this := &VTDblStr{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = randStringVepr(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntDbl(r randyVepr, easy bool) *VTIntDbl {
	this := &VTIntDbl{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntInt(r randyVepr, easy bool) *VTIntInt {
	this := &VTIntInt{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntStr(r randyVepr, easy bool) *VTIntStr {
	this := &VTIntStr{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = randStringVepr(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrDbl(r randyVepr, easy bool) *VTStrDbl {
	this := &VTStrDbl{}
	this.Key = randStringVepr(r)
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrInt(r randyVepr, easy bool) *VTStrInt {
	this := &VTStrInt{}
	this.Key = randStringVepr(r)
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrStr(r randyVepr, easy bool) *VTStrStr {
	this := &VTStrStr{}
	this.Key = randStringVepr(r)
	this.Value = randStringVepr(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDbl(r randyVepr, easy bool) *VLDbl {
	this := &VLDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v2 := r.Intn(10)
	this.Vec = make([]float64, v2)
	for i := 0; i < v2; i++ {
		this.Vec[i] = float64(r.Float64())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLInt(r randyVepr, easy bool) *VLInt {
	this := &VLInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v3 := r.Intn(10)
	this.Vec = make([]int64, v3)
	for i := 0; i < v3; i++ {
		this.Vec[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStr(r randyVepr, easy bool) *VLStr {
	this := &VLStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v4 := r.Intn(10)
	this.Vec = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.Vec[i] = randStringVepr(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblDbl(r randyVepr, easy bool) *VLDblDbl {
	this := &VLDblDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Vec = make([]*VTDblDbl, v5)
		for i := 0; i < v5; i++ {
			this.Vec[i] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblInt(r randyVepr, easy bool) *VLDblInt {
	this := &VLDblInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Vec = make([]*VTDblInt, v6)
		for i := 0; i < v6; i++ {
			this.Vec[i] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblStr(r randyVepr, easy bool) *VLDblStr {
	this := &VLDblStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Vec = make([]*VTDblStr, v7)
		for i := 0; i < v7; i++ {
			this.Vec[i] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntDbl(r randyVepr, easy bool) *VLIntDbl {
	this := &VLIntDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Vec = make([]*VTIntDbl, v8)
		for i := 0; i < v8; i++ {
			this.Vec[i] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntInt(r randyVepr, easy bool) *VLIntInt {
	this := &VLIntInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Vec = make([]*VTIntInt, v9)
		for i := 0; i < v9; i++ {
			this.Vec[i] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntStr(r randyVepr, easy bool) *VLIntStr {
	this := &VLIntStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Vec = make([]*VTIntStr, v10)
		for i := 0; i < v10; i++ {
			this.Vec[i] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrDbl(r randyVepr, easy bool) *VLStrDbl {
	this := &VLStrDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.Vec = make([]*VTStrDbl, v11)
		for i := 0; i < v11; i++ {
			this.Vec[i] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrInt(r randyVepr, easy bool) *VLStrInt {
	this := &VLStrInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.Vec = make([]*VTStrInt, v12)
		for i := 0; i < v12; i++ {
			this.Vec[i] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrStr(r randyVepr, easy bool) *VLStrStr {
	this := &VLStrStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Vec = make([]*VTStrStr, v13)
		for i := 0; i < v13; i++ {
			this.Vec[i] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDbl(r randyVepr, easy bool) *VSDbl {
	this := &VSDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v14 := r.Intn(10)
	this.Vec = make([]float64, v14)
	for i := 0; i < v14; i++ {
		this.Vec[i] = float64(r.Float64())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSInt(r randyVepr, easy bool) *VSInt {
	this := &VSInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v15 := r.Intn(10)
	this.Vec = make([]int64, v15)
	for i := 0; i < v15; i++ {
		this.Vec[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStr(r randyVepr, easy bool) *VSStr {
	this := &VSStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	v16 := r.Intn(10)
	this.Vec = make([]string, v16)
	for i := 0; i < v16; i++ {
		this.Vec[i] = randStringVepr(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblDbl(r randyVepr, easy bool) *VSDblDbl {
	this := &VSDblDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Vec = make([]*VTDblDbl, v17)
		for i := 0; i < v17; i++ {
			this.Vec[i] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblInt(r randyVepr, easy bool) *VSDblInt {
	this := &VSDblInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Vec = make([]*VTDblInt, v18)
		for i := 0; i < v18; i++ {
			this.Vec[i] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblStr(r randyVepr, easy bool) *VSDblStr {
	this := &VSDblStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Vec = make([]*VTDblStr, v19)
		for i := 0; i < v19; i++ {
			this.Vec[i] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntDbl(r randyVepr, easy bool) *VSIntDbl {
	this := &VSIntDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Vec = make([]*VTIntDbl, v20)
		for i := 0; i < v20; i++ {
			this.Vec[i] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntInt(r randyVepr, easy bool) *VSIntInt {
	this := &VSIntInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Vec = make([]*VTIntInt, v21)
		for i := 0; i < v21; i++ {
			this.Vec[i] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntStr(r randyVepr, easy bool) *VSIntStr {
	this := &VSIntStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.Vec = make([]*VTIntStr, v22)
		for i := 0; i < v22; i++ {
			this.Vec[i] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrDbl(r randyVepr, easy bool) *VSStrDbl {
	this := &VSStrDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Vec = make([]*VTStrDbl, v23)
		for i := 0; i < v23; i++ {
			this.Vec[i] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrInt(r randyVepr, easy bool) *VSStrInt {
	this := &VSStrInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.Vec = make([]*VTStrInt, v24)
		for i := 0; i < v24; i++ {
			this.Vec[i] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrStr(r randyVepr, easy bool) *VSStrStr {
	this := &VSStrStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v25 := r.Intn(5)
		this.Vec = make([]*VTStrStr, v25)
		for i := 0; i < v25; i++ {
			this.Vec[i] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntDbl(r randyVepr, easy bool) *VMIntDbl {
	this := &VMIntDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v26 := r.Intn(10)
		this.Vec = make(map[int64]float64)
		for i := 0; i < v26; i++ {
			v27 := int64(r.Int63())
			this.Vec[v27] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Vec[v27] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntInt(r randyVepr, easy bool) *VMIntInt {
	this := &VMIntInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v28 := r.Intn(10)
		this.Vec = make(map[int64]int64)
		for i := 0; i < v28; i++ {
			v29 := int64(r.Int63())
			this.Vec[v29] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Vec[v29] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntStr(r randyVepr, easy bool) *VMIntStr {
	this := &VMIntStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v30 := r.Intn(10)
		this.Vec = make(map[int64]string)
		for i := 0; i < v30; i++ {
			this.Vec[int64(r.Int63())] = randStringVepr(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrDbl(r randyVepr, easy bool) *VMStrDbl {
	this := &VMStrDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(10)
		this.Vec = make(map[string]float64)
		for i := 0; i < v31; i++ {
			v32 := randStringVepr(r)
			this.Vec[v32] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Vec[v32] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrInt(r randyVepr, easy bool) *VMStrInt {
	this := &VMStrInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v33 := r.Intn(10)
		this.Vec = make(map[string]int64)
		for i := 0; i < v33; i++ {
			v34 := randStringVepr(r)
			this.Vec[v34] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Vec[v34] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrStr(r randyVepr, easy bool) *VMStrStr {
	this := &VMStrStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v35 := r.Intn(10)
		this.Vec = make(map[string]string)
		for i := 0; i < v35; i++ {
			this.Vec[randStringVepr(r)] = randStringVepr(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblDbl(r randyVepr, easy bool) *VMIntTPDblDbl {
	this := &VMIntTPDblDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblDbl)
		for i := 0; i < v36; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblInt(r randyVepr, easy bool) *VMIntTPDblInt {
	this := &VMIntTPDblInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v37 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblInt)
		for i := 0; i < v37; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblStr(r randyVepr, easy bool) *VMIntTPDblStr {
	this := &VMIntTPDblStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v38 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblStr)
		for i := 0; i < v38; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntDbl(r randyVepr, easy bool) *VMIntTPIntDbl {
	this := &VMIntTPIntDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v39 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntDbl)
		for i := 0; i < v39; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntInt(r randyVepr, easy bool) *VMIntTPIntInt {
	this := &VMIntTPIntInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v40 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntInt)
		for i := 0; i < v40; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntStr(r randyVepr, easy bool) *VMIntTPIntStr {
	this := &VMIntTPIntStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntStr)
		for i := 0; i < v41; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrDbl(r randyVepr, easy bool) *VMIntTPStrDbl {
	this := &VMIntTPStrDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v42 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrDbl)
		for i := 0; i < v42; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrInt(r randyVepr, easy bool) *VMIntTPStrInt {
	this := &VMIntTPStrInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrInt)
		for i := 0; i < v43; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrStr(r randyVepr, easy bool) *VMIntTPStrStr {
	this := &VMIntTPStrStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v44 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrStr)
		for i := 0; i < v44; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblDbl(r randyVepr, easy bool) *VMStrTPDblDbl {
	this := &VMStrTPDblDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(10)
		this.Vec = make(map[string]*VTDblDbl)
		for i := 0; i < v45; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblInt(r randyVepr, easy bool) *VMStrTPDblInt {
	this := &VMStrTPDblInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v46 := r.Intn(10)
		this.Vec = make(map[string]*VTDblInt)
		for i := 0; i < v46; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblStr(r randyVepr, easy bool) *VMStrTPDblStr {
	this := &VMStrTPDblStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v47 := r.Intn(10)
		this.Vec = make(map[string]*VTDblStr)
		for i := 0; i < v47; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntDbl(r randyVepr, easy bool) *VMStrTPIntDbl {
	this := &VMStrTPIntDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v48 := r.Intn(10)
		this.Vec = make(map[string]*VTIntDbl)
		for i := 0; i < v48; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntInt(r randyVepr, easy bool) *VMStrTPIntInt {
	this := &VMStrTPIntInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v49 := r.Intn(10)
		this.Vec = make(map[string]*VTIntInt)
		for i := 0; i < v49; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntStr(r randyVepr, easy bool) *VMStrTPIntStr {
	this := &VMStrTPIntStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v50 := r.Intn(10)
		this.Vec = make(map[string]*VTIntStr)
		for i := 0; i < v50; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrDbl(r randyVepr, easy bool) *VMStrTPStrDbl {
	this := &VMStrTPStrDbl{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v51 := r.Intn(10)
		this.Vec = make(map[string]*VTStrDbl)
		for i := 0; i < v51; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrInt(r randyVepr, easy bool) *VMStrTPStrInt {
	this := &VMStrTPStrInt{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(10)
		this.Vec = make(map[string]*VTStrInt)
		for i := 0; i < v52; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrStr(r randyVepr, easy bool) *VMStrTPStrStr {
	this := &VMStrTPStrStr{}
	if r.Intn(10) != 0 {
		this.Name = NewPopulatedVName(r, easy)
	}
	if r.Intn(10) != 0 {
		v53 := r.Intn(10)
		this.Vec = make(map[string]*VTStrStr)
		for i := 0; i < v53; i++ {
			this.Vec[randStringVepr(r)] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyVepr interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneVepr(r randyVepr) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringVepr(r randyVepr) string {
	v54 := r.Intn(100)
	tmps := make([]rune, v54)
	for i := 0; i < v54; i++ {
		tmps[i] = randUTF8RuneVepr(r)
	}
	return string(tmps)
}
func randUnrecognizedVepr(r randyVepr, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldVepr(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldVepr(data []byte, r randyVepr, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateVepr(data, uint64(key))
		v55 := r.Int63()
		if r.Intn(2) == 0 {
			v55 *= -1
		}
		data = encodeVarintPopulateVepr(data, uint64(v55))
	case 1:
		data = encodeVarintPopulateVepr(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateVepr(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateVepr(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateVepr(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateVepr(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	return n
}

func (m *VName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovVepr(uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		n += 1 + sovVepr(uint64(m.Ttl))
	}
	if m.XUniqueId != 0 {
		n += 1 + sovVepr(uint64(m.XUniqueId))
	}
	l = len(m.XUniqueStr)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VTDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 1 + sovVepr(uint64(m.Value))
	}
	return n
}

func (m *VTDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	return n
}

func (m *VTIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovVepr(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovVepr(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovVepr(uint64(m.Value))
	}
	return n
}

func (m *VTIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovVepr(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	return n
}

func (m *VTStrDbl) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTStrInt) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovVepr(uint64(m.Value))
	}
	return n
}

func (m *VTStrStr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVepr(uint64(l))
	}
	return n
}

func (m *VLDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		n += 1 + sovVepr(uint64(len(m.Vec)*8)) + len(m.Vec)*8
	}
	return n
}

func (m *VLInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		l = 0
		for _, e := range m.Vec {
			l += sovVepr(uint64(e))
		}
		n += 1 + sovVepr(uint64(l)) + l
	}
	return n
}

func (m *VLStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			l = len(s)
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLStrDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLStrInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VLStrStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		n += 1 + sovVepr(uint64(len(m.Vec)*8)) + len(m.Vec)*8
	}
	return n
}

func (m *VSInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		l = 0
		for _, e := range m.Vec {
			l += sovVepr(uint64(e))
		}
		n += 1 + sovVepr(uint64(l)) + l
	}
	return n
}

func (m *VSStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			l = len(s)
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSStrDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSStrInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VSStrStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovVepr(uint64(l))
		}
	}
	return n
}

func (m *VMIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVepr(uint64(k)) + 1 + 8
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVepr(uint64(k)) + 1 + sovVepr(uint64(v))
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVepr(uint64(k)) + 1 + len(v) + sovVepr(uint64(len(v)))
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + sovVepr(uint64(v))
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + 1 + len(v) + sovVepr(uint64(len(v)))
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + sovVepr(uint64(k)) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrDbl) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrInt) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrStr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovVepr(uint64(l))
	}
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVepr(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVepr(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVepr(uint64(mapEntrySize))
		}
	}
	return n
}

func sovVepr(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVepr(x uint64) (n int) {
	return sovVepr(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tag) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VName) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (github_com_wyndhblb_timeslab.Resolution(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XUniqueId", wireType)
			}
			m.XUniqueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.XUniqueId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XUniqueStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XUniqueStr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVepr
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vec = append(m.Vec, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vec = append(m.Vec, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVepr
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVepr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vec = append(m.Vec, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec = append(m.Vec, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVepr
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vec = append(m.Vec, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vec = append(m.Vec, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVepr
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVepr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vec = append(m.Vec, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec = append(m.Vec, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthVepr
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthVepr
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &VName{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVepr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthVepr
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthVepr
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVepr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVepr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVepr(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVepr
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVepr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVepr
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVepr
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVepr(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVepr = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVepr   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("vepr.proto", fileDescriptorVepr) }

var fileDescriptorVepr = []byte{
	// 960 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xc4, 0x5a, 0xcd, 0x6a, 0xdb, 0x4a,
	0x18, 0x8d, 0x2c, 0xfb, 0xe2, 0x19, 0x93, 0x4b, 0xd0, 0xbd, 0x0b, 0x11, 0xb8, 0xb6, 0xf1, 0xca,
	0x10, 0x22, 0xdf, 0x3a, 0xa5, 0x84, 0x42, 0x37, 0x26, 0x85, 0x1a, 0xda, 0x50, 0x3c, 0xae, 0x29,
	0xd9, 0x14, 0xdb, 0x51, 0x1c, 0x53, 0x47, 0x4e, 0xe5, 0x91, 0x4b, 0x1e, 0xa2, 0xd0, 0xa7, 0xe9,
	0xba, 0xcb, 0x2c, 0xfb, 0x04, 0xa1, 0x71, 0xbb, 0xea, 0x13, 0x74, 0x59, 0x34, 0x92, 0xe2, 0x91,
	0x2c, 0x59, 0x1a, 0xfd, 0x8c, 0x76, 0x92, 0xac, 0x6f, 0xce, 0x39, 0xa3, 0x33, 0xdf, 0x77, 0x02,
	0x81, 0x70, 0xa9, 0x5e, 0xeb, 0xca, 0xb5, 0x3e, 0xc7, 0x73, 0x49, 0x9e, 0x4c, 0xf1, 0xa5, 0x31,
	0x52, 0xc6, 0xf3, 0x2b, 0xe5, 0xe3, 0x8d, 0x76, 0x7e, 0x39, 0x9a, 0x8d, 0x94, 0x8b, 0xa5, 0x3a,
	0xde, 0x3f, 0x5c, 0xff, 0xd2, 0x9a, 0xcc, 0x27, 0xf3, 0x16, 0x29, 0x18, 0x19, 0x17, 0xe4, 0x8e,
	0xdc, 0x90, 0x2b, 0x6b, 0xa1, 0xfd, 0x03, 0xea, 0x75, 0x67, 0xa1, 0x16, 0x9e, 0x5e, 0xa9, 0x8b,
	0xd9, 0x70, 0x7d, 0x61, 0xbd, 0xdc, 0x68, 0x41, 0xb1, 0x3f, 0x9c, 0x48, 0x12, 0x2c, 0x6a, 0xc3,
	0x2b, 0x55, 0x16, 0xea, 0x42, 0x13, 0xf4, 0xc8, 0xb5, 0xf4, 0x2f, 0x2c, 0x2d, 0x87, 0x33, 0x43,
	0x95, 0x0b, 0xe4, 0xa1, 0x75, 0xd3, 0xf8, 0x54, 0x80, 0xa5, 0xc1, 0xa9, 0xf9, 0xfb, 0x1e, 0x14,
	0xdf, 0xab, 0x37, 0x76, 0x89, 0x79, 0x29, 0xbd, 0x80, 0x50, 0x57, 0x17, 0xf3, 0x99, 0x81, 0xa7,
	0x73, 0x8d, 0x94, 0xfd, 0xdd, 0x6e, 0x2a, 0x7e, 0xba, 0x1e, 0x58, 0xf4, 0x1e, 0xde, 0xef, 0x51,
	0xb5, 0xe6, 0xda, 0x18, 0xcf, 0x64, 0xb1, 0x2e, 0x34, 0x77, 0x7b, 0xe6, 0xa5, 0xd4, 0x82, 0xc0,
	0xd0, 0xa6, 0x1f, 0x0c, 0xf5, 0xdd, 0xf4, 0x5c, 0x2e, 0xd6, 0x85, 0x66, 0xb1, 0x23, 0xad, 0xee,
	0x6a, 0xe0, 0xed, 0x1b, 0xf2, 0xb4, 0x7b, 0xfe, 0xeb, 0xae, 0x26, 0x1c, 0xf6, 0xca, 0x86, 0x7d,
	0x2b, 0xb5, 0x21, 0xb4, 0x0b, 0x16, 0x58, 0x97, 0x4b, 0x26, 0xcb, 0xce, 0x3f, 0xab, 0xbb, 0x1a,
	0xb4, 0x2b, 0x10, 0xd6, 0xad, 0x12, 0x7b, 0x5d, 0x84, 0x75, 0xe9, 0x11, 0x2c, 0xe2, 0xe1, 0x64,
	0x21, 0x57, 0xea, 0x62, 0xb3, 0xd2, 0xfe, 0x4f, 0x09, 0xfa, 0x24, 0x4a, 0x7f, 0x38, 0xe9, 0x91,
	0x57, 0x1b, 0x6d, 0x58, 0x1e, 0xf4, 0x4f, 0x46, 0xb3, 0x93, 0xd1, 0x8c, 0xde, 0x11, 0xc1, 0xda,
	0x11, 0xd7, 0x1e, 0x0a, 0xce, 0x1e, 0x3a, 0x35, 0x5d, 0x0d, 0x87, 0xd5, 0x88, 0xde, 0x1a, 0x93,
	0x66, 0x48, 0x0d, 0x70, 0xd5, 0x74, 0x35, 0xec, 0xe1, 0x26, 0x86, 0x72, 0xeb, 0x6a, 0xd8, 0xc3,
	0x4d, 0x0c, 0xe5, 0xd6, 0xd5, 0xb0, 0x87, 0x9b, 0x18, 0xca, 0x0d, 0x61, 0xdd, 0xc3, 0x0d, 0x84,
	0x72, 0x43, 0x58, 0xf7, 0x70, 0x03, 0xa1, 0xdc, 0x10, 0xd6, 0x3d, 0xdc, 0xc0, 0x36, 0x6e, 0xa7,
	0xb0, 0x34, 0x78, 0x69, 0x12, 0x3b, 0xa2, 0x8e, 0x45, 0xa5, 0x5d, 0x0b, 0xf6, 0x03, 0x39, 0x11,
	0xf6, 0xb9, 0xd9, 0x83, 0xe2, 0x52, 0x1d, 0xcb, 0x85, 0xba, 0x68, 0x7e, 0x9d, 0xa5, 0x3a, 0xb6,
	0xd6, 0x33, 0x49, 0x27, 0x5d, 0x4f, 0xa4, 0xd6, 0x33, 0x05, 0x25, 0x5d, 0x0f, 0x58, 0xeb, 0x19,
	0xb0, 0x4c, 0xf4, 0xc6, 0x96, 0xfc, 0x78, 0xbd, 0x64, 0xa5, 0xdd, 0xd8, 0x52, 0x63, 0x9f, 0x14,
	0x37, 0x6c, 0xec, 0x9d, 0x61, 0x82, 0xed, 0x6a, 0xd8, 0x0d, 0x1b, 0x7b, 0x03, 0x99, 0x60, 0x11,
	0xd6, 0x29, 0x58, 0xfb, 0x30, 0x66, 0x0c, 0x6b, 0xa1, 0xb8, 0x61, 0x39, 0x6c, 0xb2, 0x85, 0xe2,
	0x86, 0xe5, 0xb0, 0xc9, 0x16, 0x0a, 0x05, 0x6b, 0x77, 0x95, 0x8c, 0x61, 0x2d, 0x14, 0x37, 0x2c,
	0x87, 0x4d, 0xb6, 0x50, 0xdc, 0xb0, 0x1c, 0x36, 0xd9, 0x42, 0x59, 0xb7, 0x1f, 0x94, 0x72, 0x7b,
	0x44, 0x29, 0xb7, 0x47, 0x94, 0x72, 0x7b, 0x44, 0xf9, 0xb4, 0x47, 0x94, 0x4f, 0x7b, 0x44, 0xf9,
	0xb4, 0x47, 0x94, 0x4f, 0x7b, 0x44, 0xf9, 0xb4, 0x47, 0x94, 0x4f, 0x7b, 0x44, 0xf9, 0xb4, 0x47,
	0x94, 0x4f, 0x7b, 0x44, 0xfc, 0xdb, 0xe3, 0x17, 0x01, 0x96, 0x07, 0xaf, 0x92, 0x58, 0xf9, 0x19,
	0x8d, 0x7b, 0xb0, 0xa5, 0xc6, 0x46, 0x51, 0x06, 0xea, 0xf8, 0xb9, 0x86, 0xf5, 0x1b, 0x42, 0x60,
	0xff, 0x09, 0x2c, 0x3b, 0x0f, 0xa2, 0xc6, 0xfe, 0xa7, 0x85, 0x63, 0x61, 0x4d, 0x3c, 0xf6, 0x77,
	0x62, 0x22, 0xde, 0xd5, 0x70, 0x7c, 0xe2, 0xa2, 0x2f, 0xf1, 0xd8, 0x5f, 0x9a, 0x89, 0x38, 0xc2,
	0x7a, 0x7c, 0xe2, 0x60, 0x93, 0x78, 0x92, 0x03, 0x19, 0x9d, 0xb8, 0x85, 0x12, 0x8d, 0x38, 0x88,
	0x66, 0x95, 0x24, 0x47, 0x9a, 0x89, 0x78, 0x64, 0xab, 0x80, 0x68, 0x56, 0x49, 0xd2, 0x14, 0x98,
	0x88, 0x47, 0xb6, 0x0a, 0x08, 0xb3, 0xca, 0x4f, 0x01, 0xee, 0x12, 0xf7, 0xf5, 0x5f, 0x27, 0x89,
	0x22, 0x1d, 0x9a, 0xfd, 0xff, 0x21, 0x46, 0x77, 0xa0, 0x3c, 0x12, 0xce, 0xb6, 0xba, 0xfd, 0x98,
	0x96, 0x10, 0x2d, 0xee, 0x04, 0xca, 0x8c, 0xed, 0x2e, 0x76, 0x99, 0x9b, 0x16, 0x4b, 0x55, 0xa6,
	0x39, 0x94, 0x02, 0x65, 0xc6, 0xf6, 0x22, 0xbb, 0xcc, 0x4d, 0x43, 0xa6, 0x2a, 0xd3, 0x1c, 0x82,
	0xfe, 0x32, 0x93, 0xcc, 0x43, 0x46, 0x99, 0xbe, 0x43, 0x31, 0x3d, 0x99, 0x76, 0x7c, 0x0c, 0x94,
	0xc9, 0xcb, 0xb4, 0xbe, 0x23, 0x34, 0x55, 0x99, 0xc1, 0xa6, 0x4d, 0x32, 0x6b, 0xd9, 0x65, 0x66,
	0x69, 0x5a, 0x3b, 0x1e, 0xfb, 0xcb, 0x4c, 0x32, 0x99, 0x19, 0x65, 0xfa, 0x8e, 0xe7, 0xf4, 0x64,
	0xda, 0x71, 0x3c, 0x50, 0x26, 0x2f, 0xd3, 0xfa, 0x0e, 0xf3, 0x54, 0x65, 0x06, 0x9b, 0x36, 0xc9,
	0xd4, 0x67, 0x97, 0x99, 0xa5, 0x69, 0xed, 0x3f, 0x37, 0x36, 0x64, 0x22, 0xac, 0xf3, 0x8a, 0x07,
	0x14, 0x54, 0x34, 0x99, 0x20, 0xbd, 0x78, 0xe0, 0x60, 0x73, 0x30, 0x2d, 0x05, 0x95, 0xa5, 0x4c,
	0x5f, 0xd3, 0x3a, 0xd8, 0x1c, 0x4c, 0x4b, 0x41, 0x65, 0x29, 0x33, 0xd8, 0xb4, 0x7c, 0xe2, 0x01,
	0x05, 0x95, 0x99, 0xcc, 0xa0, 0x78, 0xe0, 0x60, 0xf3, 0x32, 0x2d, 0x4b, 0x3c, 0x00, 0xe9, 0xc5,
	0x03, 0x07, 0x9b, 0x97, 0x69, 0x59, 0xe2, 0x01, 0x48, 0x2f, 0x1e, 0x10, 0x6c, 0x3e, 0xf1, 0x80,
	0x82, 0xca, 0x4c, 0x66, 0x50, 0x3c, 0x70, 0xb0, 0x79, 0x99, 0x96, 0x25, 0x1e, 0x80, 0xf4, 0xe2,
	0x81, 0x83, 0xcd, 0xcb, 0xb4, 0x2c, 0xf1, 0x00, 0xa4, 0x10, 0x0f, 0x3a, 0x8d, 0xdb, 0xfb, 0xea,
	0xce, 0xef, 0xfb, 0xaa, 0xf0, 0x75, 0x55, 0x15, 0x6e, 0x57, 0x55, 0xe1, 0xdb, 0xaa, 0x2a, 0x7c,
	0x5f, 0x55, 0x85, 0xcf, 0x3f, 0xaa, 0x3b, 0x67, 0xc5, 0xa5, 0x7a, 0xad, 0x8f, 0xfe, 0x22, 0xff,
	0x11, 0x72, 0xf4, 0x27, 0x00, 0x00, 0xff, 0xff, 0x17, 0xb9, 0xee, 0x9f, 0x95, 0x22, 0x00, 0x00,
}
