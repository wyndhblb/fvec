// Code generated by protoc-gen-gogo.
// source: fvec.proto
// DO NOT EDIT!

/*
	Package fvec is a generated protocol buffer package.

	It is generated from these files:
		fvec.proto

	It has these top-level messages:
		Tag
		VName
		VTDblDbl
		VTDblStr
		VTDblInt
		VTStrDbl
		VTStrStr
		VTStrInt
		VTIntDbl
		VTIntStr
		VTIntInt
		VLDbl
		VLStr
		VLInt
		VLDblDbl
		VLDblStr
		VLDblInt
		VLStrDbl
		VLStrStr
		VLStrInt
		VLIntDbl
		VLIntStr
		VLIntInt
		VSDbl
		VSStr
		VSInt
		VSDblDbl
		VSDblStr
		VSDblInt
		VSStrDbl
		VSStrStr
		VSStrInt
		VSIntDbl
		VSIntStr
		VSIntInt
		VMStrDbl
		VMStrStr
		VMStrInt
		VMIntDbl
		VMIntStr
		VMIntInt
		VMStrTPDblDbl
		VMStrTPDblStr
		VMStrTPDblInt
		VMStrTPStrDbl
		VMStrTPStrStr
		VMStrTPStrInt
		VMStrTPIntDbl
		VMStrTPIntStr
		VMStrTPIntInt
		VMIntTPDblDbl
		VMIntTPDblStr
		VMIntTPDblInt
		VMIntTPStrDbl
		VMIntTPStrStr
		VMIntTPStrInt
		VMIntTPIntDbl
		VMIntTPIntStr
		VMIntTPIntInt
*/
package fvec

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import github_com_wyndhblb_timeslab "github.com/wyndhblb/timeslab"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// easyjson:json
type Tag struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{0} }

// VN the base name for a given indexible element
// easyjson:json
type VName struct {
	// @inject_tag: cql:"key" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"key" msg:"key"`
	// @inject_tag: cql:"res" msg:"res"
	Resolution github_com_wyndhblb_timeslab.Resolution `protobuf:"varint,2,opt,name=resolution,proto3,enum=github.com.wyndhblb.timeslab.Resolution" json:"resolution,omitempty" cql:"res" msg:"res"`
	// @inject_tag: cql:"ttl" msg:"ttl"
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty" cql:"ttl" msg:"ttl"`
	// @inject_tag: cql:"-" msg:"-"
	XUniqueId uint64 `protobuf:"varint,4,opt,name=unique_id,json=uniqueId,proto3" json:"-" cql:"-" msg:"-"`
	// @inject_tag: cql:"uid" msg:"uid"
	XUniqueStr string `protobuf:"bytes,5,opt,name=unique_str,json=uniqueStr,proto3" json:"-" cql:"uid" msg:"uid"`
	// @inject_tag: cql:"time" msg:"time"
	Time int64 `protobuf:"varint,6,opt,name=time,proto3" json:"time,omitempty" cql:"time" msg:"time"`
	// @inject_tag: cql:"tags" msg:"tags"
	Tags []*Tag `protobuf:"bytes,11,rep,name=tags" json:"tags,omitempty" cql:"tags" msg:"tags"`
}

func (m *VName) Reset()                    { *m = VName{} }
func (m *VName) String() string            { return proto.CompactTextString(m) }
func (*VName) ProtoMessage()               {}
func (*VName) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{1} }

// VTDblDbl Tuple Type key=double value=double
// easyjson:json
type VTDblDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblDbl) Reset()                    { *m = VTDblDbl{} }
func (m *VTDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VTDblDbl) ProtoMessage()               {}
func (*VTDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{2} }

// VTDblStr Tuple Type key=double value=string
// easyjson:json
type VTDblStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblStr) Reset()                    { *m = VTDblStr{} }
func (m *VTDblStr) String() string            { return proto.CompactTextString(m) }
func (*VTDblStr) ProtoMessage()               {}
func (*VTDblStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{3} }

// VTDblInt Tuple Type key=double value=int64
// easyjson:json
type VTDblInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key float64 `protobuf:"fixed64,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTDblInt) Reset()                    { *m = VTDblInt{} }
func (m *VTDblInt) String() string            { return proto.CompactTextString(m) }
func (*VTDblInt) ProtoMessage()               {}
func (*VTDblInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{4} }

// VTStrDbl Tuple Type key=string value=double
// easyjson:json
type VTStrDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrDbl) Reset()                    { *m = VTStrDbl{} }
func (m *VTStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VTStrDbl) ProtoMessage()               {}
func (*VTStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{5} }

// VTStrStr Tuple Type key=string value=string
// easyjson:json
type VTStrStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrStr) Reset()                    { *m = VTStrStr{} }
func (m *VTStrStr) String() string            { return proto.CompactTextString(m) }
func (*VTStrStr) ProtoMessage()               {}
func (*VTStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{6} }

// VTStrInt Tuple Type key=string value=int64
// easyjson:json
type VTStrInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTStrInt) Reset()                    { *m = VTStrInt{} }
func (m *VTStrInt) String() string            { return proto.CompactTextString(m) }
func (*VTStrInt) ProtoMessage()               {}
func (*VTStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{7} }

// VTIntDbl Tuple Type key=int64 value=double
// easyjson:json
type VTIntDbl struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntDbl) Reset()                    { *m = VTIntDbl{} }
func (m *VTIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VTIntDbl) ProtoMessage()               {}
func (*VTIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{8} }

// VTIntStr Tuple Type key=int64 value=string
// easyjson:json
type VTIntStr struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntStr) Reset()                    { *m = VTIntStr{} }
func (m *VTIntStr) String() string            { return proto.CompactTextString(m) }
func (*VTIntStr) ProtoMessage()               {}
func (*VTIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{9} }

// VTIntInt Tuple Type key=int64 value=int64
// easyjson:json
type VTIntInt struct {
	// @inject_tag: cql:"k" msg:"key"
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty" cql:"k" msg:"key"`
	// @inject_tag: cql:"v" msg:"value"
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty" cql:"v" msg:"value"`
}

func (m *VTIntInt) Reset()                    { *m = VTIntInt{} }
func (m *VTIntInt) String() string            { return proto.CompactTextString(m) }
func (*VTIntInt) ProtoMessage()               {}
func (*VTIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{10} }

// VLDbl list
// easyjson:json
type VLDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []float64 `protobuf:"fixed64,1,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDbl) Reset()                    { *m = VLDbl{} }
func (m *VLDbl) String() string            { return proto.CompactTextString(m) }
func (*VLDbl) ProtoMessage()               {}
func (*VLDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{11} }

// VLStr list
// easyjson:json
type VLStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []string `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStr) Reset()                    { *m = VLStr{} }
func (m *VLStr) String() string            { return proto.CompactTextString(m) }
func (*VLStr) ProtoMessage()               {}
func (*VLStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{12} }

// VLInt list
// easyjson:json
type VLInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []int64 `protobuf:"varint,1,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLInt) Reset()                    { *m = VLInt{} }
func (m *VLInt) String() string            { return proto.CompactTextString(m) }
func (*VLInt) ProtoMessage()               {}
func (*VLInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{13} }

// VLDblDbl list
// easyjson:json
type VLDblDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblDbl) Reset()                    { *m = VLDblDbl{} }
func (m *VLDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VLDblDbl) ProtoMessage()               {}
func (*VLDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{14} }

// VLDblStr list
// easyjson:json
type VLDblStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblStr) Reset()                    { *m = VLDblStr{} }
func (m *VLDblStr) String() string            { return proto.CompactTextString(m) }
func (*VLDblStr) ProtoMessage()               {}
func (*VLDblStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{15} }

// VLDblInt list
// easyjson:json
type VLDblInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLDblInt) Reset()                    { *m = VLDblInt{} }
func (m *VLDblInt) String() string            { return proto.CompactTextString(m) }
func (*VLDblInt) ProtoMessage()               {}
func (*VLDblInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{16} }

// VLStrDbl list
// easyjson:json
type VLStrDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrDbl) Reset()                    { *m = VLStrDbl{} }
func (m *VLStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VLStrDbl) ProtoMessage()               {}
func (*VLStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{17} }

// VLStrStr list
// easyjson:json
type VLStrStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrStr) Reset()                    { *m = VLStrStr{} }
func (m *VLStrStr) String() string            { return proto.CompactTextString(m) }
func (*VLStrStr) ProtoMessage()               {}
func (*VLStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{18} }

// VLStrInt list
// easyjson:json
type VLStrInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLStrInt) Reset()                    { *m = VLStrInt{} }
func (m *VLStrInt) String() string            { return proto.CompactTextString(m) }
func (*VLStrInt) ProtoMessage()               {}
func (*VLStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{19} }

// VLIntDbl list
// easyjson:json
type VLIntDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntDbl) Reset()                    { *m = VLIntDbl{} }
func (m *VLIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VLIntDbl) ProtoMessage()               {}
func (*VLIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{20} }

// VLIntStr list
// easyjson:json
type VLIntStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntStr) Reset()                    { *m = VLIntStr{} }
func (m *VLIntStr) String() string            { return proto.CompactTextString(m) }
func (*VLIntStr) ProtoMessage()               {}
func (*VLIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{21} }

// VLIntInt list
// easyjson:json
type VLIntInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VLIntInt) Reset()                    { *m = VLIntInt{} }
func (m *VLIntInt) String() string            { return proto.CompactTextString(m) }
func (*VLIntInt) ProtoMessage()               {}
func (*VLIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{22} }

// VSDbl set
// easyjson:json
type VSDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []float64 `protobuf:"fixed64,1,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDbl) Reset()                    { *m = VSDbl{} }
func (m *VSDbl) String() string            { return proto.CompactTextString(m) }
func (*VSDbl) ProtoMessage()               {}
func (*VSDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{23} }

// VSStr set
// easyjson:json
type VSStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []string `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStr) Reset()                    { *m = VSStr{} }
func (m *VSStr) String() string            { return proto.CompactTextString(m) }
func (*VSStr) ProtoMessage()               {}
func (*VSStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{24} }

// VSInt set
// easyjson:json
type VSInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []int64 `protobuf:"varint,1,rep,packed,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSInt) Reset()                    { *m = VSInt{} }
func (m *VSInt) String() string            { return proto.CompactTextString(m) }
func (*VSInt) ProtoMessage()               {}
func (*VSInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{25} }

// VSDblDbl set
// easyjson:json
type VSDblDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblDbl) Reset()                    { *m = VSDblDbl{} }
func (m *VSDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VSDblDbl) ProtoMessage()               {}
func (*VSDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{26} }

// VSDblStr set
// easyjson:json
type VSDblStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblStr) Reset()                    { *m = VSDblStr{} }
func (m *VSDblStr) String() string            { return proto.CompactTextString(m) }
func (*VSDblStr) ProtoMessage()               {}
func (*VSDblStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{27} }

// VSDblInt set
// easyjson:json
type VSDblInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTDblInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSDblInt) Reset()                    { *m = VSDblInt{} }
func (m *VSDblInt) String() string            { return proto.CompactTextString(m) }
func (*VSDblInt) ProtoMessage()               {}
func (*VSDblInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{28} }

// VSStrDbl set
// easyjson:json
type VSStrDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrDbl) Reset()                    { *m = VSStrDbl{} }
func (m *VSStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VSStrDbl) ProtoMessage()               {}
func (*VSStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{29} }

// VSStrStr set
// easyjson:json
type VSStrStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrStr) Reset()                    { *m = VSStrStr{} }
func (m *VSStrStr) String() string            { return proto.CompactTextString(m) }
func (*VSStrStr) ProtoMessage()               {}
func (*VSStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{30} }

// VSStrInt set
// easyjson:json
type VSStrInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTStrInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSStrInt) Reset()                    { *m = VSStrInt{} }
func (m *VSStrInt) String() string            { return proto.CompactTextString(m) }
func (*VSStrInt) ProtoMessage()               {}
func (*VSStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{31} }

// VSIntDbl set
// easyjson:json
type VSIntDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntDbl) Reset()                    { *m = VSIntDbl{} }
func (m *VSIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VSIntDbl) ProtoMessage()               {}
func (*VSIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{32} }

// VSIntStr set
// easyjson:json
type VSIntStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntStr) Reset()                    { *m = VSIntStr{} }
func (m *VSIntStr) String() string            { return proto.CompactTextString(m) }
func (*VSIntStr) ProtoMessage()               {}
func (*VSIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{33} }

// VSIntInt set
// easyjson:json
type VSIntInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec []*VTIntInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" cql:"vec" msg:"vec"`
}

func (m *VSIntInt) Reset()                    { *m = VSIntInt{} }
func (m *VSIntInt) String() string            { return proto.CompactTextString(m) }
func (*VSIntInt) ProtoMessage()               {}
func (*VSIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{34} }

// VMStrDbl map of string -> double
// easyjson:json
type VMStrDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]float64 `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrDbl) Reset()                    { *m = VMStrDbl{} }
func (m *VMStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrDbl) ProtoMessage()               {}
func (*VMStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{35} }

// VMStrStr map of string -> string
// easyjson:json
type VMStrStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]string `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrStr) Reset()                    { *m = VMStrStr{} }
func (m *VMStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrStr) ProtoMessage()               {}
func (*VMStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{36} }

// VMStrInt map of string -> int64
// easyjson:json
type VMStrInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]int64 `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3" cql:"vec" msg:"vec"`
}

func (m *VMStrInt) Reset()                    { *m = VMStrInt{} }
func (m *VMStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrInt) ProtoMessage()               {}
func (*VMStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{37} }

type VMIntDbl struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]float64 `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntDbl) Reset()                    { *m = VMIntDbl{} }
func (m *VMIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntDbl) ProtoMessage()               {}
func (*VMIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{38} }

type VMIntStr struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]string `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntStr) Reset()                    { *m = VMIntStr{} }
func (m *VMIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntStr) ProtoMessage()               {}
func (*VMIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{39} }

type VMIntInt struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]int64 `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntInt) Reset()                    { *m = VMIntInt{} }
func (m *VMIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntInt) ProtoMessage()               {}
func (*VMIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{40} }

// VMStrTPDblDbl map of double -> set(double, double)
// easyjson:json
type VMStrTPDblDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTDblDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPDblDbl) Reset()                    { *m = VMStrTPDblDbl{} }
func (m *VMStrTPDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblDbl) ProtoMessage()               {}
func (*VMStrTPDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{41} }

// VMStrTPDblStr map of double -> set(double, string)
// easyjson:json
type VMStrTPDblStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTDblStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPDblStr) Reset()                    { *m = VMStrTPDblStr{} }
func (m *VMStrTPDblStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblStr) ProtoMessage()               {}
func (*VMStrTPDblStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{42} }

// VMStrTPDblInt map of double -> set(double, int64)
// easyjson:json
type VMStrTPDblInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTDblInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPDblInt) Reset()                    { *m = VMStrTPDblInt{} }
func (m *VMStrTPDblInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPDblInt) ProtoMessage()               {}
func (*VMStrTPDblInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{43} }

// VMStrTPStrDbl map of string -> set(string, double)
// easyjson:json
type VMStrTPStrDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTStrDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPStrDbl) Reset()                    { *m = VMStrTPStrDbl{} }
func (m *VMStrTPStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrDbl) ProtoMessage()               {}
func (*VMStrTPStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{44} }

// VMStrTPStrStr map of string -> set(string, string)
// easyjson:json
type VMStrTPStrStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTStrStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPStrStr) Reset()                    { *m = VMStrTPStrStr{} }
func (m *VMStrTPStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrStr) ProtoMessage()               {}
func (*VMStrTPStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{45} }

// VMStrTPStrInt map of string -> set(string, int64)
// easyjson:json
type VMStrTPStrInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTStrInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPStrInt) Reset()                    { *m = VMStrTPStrInt{} }
func (m *VMStrTPStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPStrInt) ProtoMessage()               {}
func (*VMStrTPStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{46} }

// VMStrTPIntDbl map of int64 -> set(int64, double)
// easyjson:json
type VMStrTPIntDbl struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTIntDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPIntDbl) Reset()                    { *m = VMStrTPIntDbl{} }
func (m *VMStrTPIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntDbl) ProtoMessage()               {}
func (*VMStrTPIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{47} }

// VMStrTPIntStr map of int64 -> set(int64, string)
// easyjson:json
type VMStrTPIntStr struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTIntStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPIntStr) Reset()                    { *m = VMStrTPIntStr{} }
func (m *VMStrTPIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntStr) ProtoMessage()               {}
func (*VMStrTPIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{48} }

// VMStrTPIntInt map of int64 -> set(int64, int64)
// easyjson:json
type VMStrTPIntInt struct {
	// @inject_tag: cql:"vec" msg:"vec"
	Vec map[string]*VTIntInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec"`
}

func (m *VMStrTPIntInt) Reset()                    { *m = VMStrTPIntInt{} }
func (m *VMStrTPIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMStrTPIntInt) ProtoMessage()               {}
func (*VMStrTPIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{49} }

type VMIntTPDblDbl struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTDblDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPDblDbl) Reset()                    { *m = VMIntTPDblDbl{} }
func (m *VMIntTPDblDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblDbl) ProtoMessage()               {}
func (*VMIntTPDblDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{50} }

type VMIntTPDblStr struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTDblStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPDblStr) Reset()                    { *m = VMIntTPDblStr{} }
func (m *VMIntTPDblStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblStr) ProtoMessage()               {}
func (*VMIntTPDblStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{51} }

type VMIntTPDblInt struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTDblInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPDblInt) Reset()                    { *m = VMIntTPDblInt{} }
func (m *VMIntTPDblInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPDblInt) ProtoMessage()               {}
func (*VMIntTPDblInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{52} }

type VMIntTPStrDbl struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTStrDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPStrDbl) Reset()                    { *m = VMIntTPStrDbl{} }
func (m *VMIntTPStrDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrDbl) ProtoMessage()               {}
func (*VMIntTPStrDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{53} }

type VMIntTPStrStr struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTStrStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPStrStr) Reset()                    { *m = VMIntTPStrStr{} }
func (m *VMIntTPStrStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrStr) ProtoMessage()               {}
func (*VMIntTPStrStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{54} }

type VMIntTPStrInt struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTStrInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPStrInt) Reset()                    { *m = VMIntTPStrInt{} }
func (m *VMIntTPStrInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPStrInt) ProtoMessage()               {}
func (*VMIntTPStrInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{55} }

type VMIntTPIntDbl struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTIntDbl `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPIntDbl) Reset()                    { *m = VMIntTPIntDbl{} }
func (m *VMIntTPIntDbl) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntDbl) ProtoMessage()               {}
func (*VMIntTPIntDbl) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{56} }

type VMIntTPIntStr struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTIntStr `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPIntStr) Reset()                    { *m = VMIntTPIntStr{} }
func (m *VMIntTPIntStr) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntStr) ProtoMessage()               {}
func (*VMIntTPIntStr) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{57} }

type VMIntTPIntInt struct {
	// @inject_tag: cql:"vec" msg:"vec,extention"
	Vec map[int64]*VTIntInt `protobuf:"bytes,1,rep,name=vec" json:"vec,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value" cql:"vec" msg:"vec,extention"`
}

func (m *VMIntTPIntInt) Reset()                    { *m = VMIntTPIntInt{} }
func (m *VMIntTPIntInt) String() string            { return proto.CompactTextString(m) }
func (*VMIntTPIntInt) ProtoMessage()               {}
func (*VMIntTPIntInt) Descriptor() ([]byte, []int) { return fileDescriptorFvec, []int{58} }

func init() {
	proto.RegisterType((*Tag)(nil), "github.com.wyndhblb.fvec.Tag")
	proto.RegisterType((*VName)(nil), "github.com.wyndhblb.fvec.VName")
	proto.RegisterType((*VTDblDbl)(nil), "github.com.wyndhblb.fvec.VTDblDbl")
	proto.RegisterType((*VTDblStr)(nil), "github.com.wyndhblb.fvec.VTDblStr")
	proto.RegisterType((*VTDblInt)(nil), "github.com.wyndhblb.fvec.VTDblInt")
	proto.RegisterType((*VTStrDbl)(nil), "github.com.wyndhblb.fvec.VTStrDbl")
	proto.RegisterType((*VTStrStr)(nil), "github.com.wyndhblb.fvec.VTStrStr")
	proto.RegisterType((*VTStrInt)(nil), "github.com.wyndhblb.fvec.VTStrInt")
	proto.RegisterType((*VTIntDbl)(nil), "github.com.wyndhblb.fvec.VTIntDbl")
	proto.RegisterType((*VTIntStr)(nil), "github.com.wyndhblb.fvec.VTIntStr")
	proto.RegisterType((*VTIntInt)(nil), "github.com.wyndhblb.fvec.VTIntInt")
	proto.RegisterType((*VLDbl)(nil), "github.com.wyndhblb.fvec.VLDbl")
	proto.RegisterType((*VLStr)(nil), "github.com.wyndhblb.fvec.VLStr")
	proto.RegisterType((*VLInt)(nil), "github.com.wyndhblb.fvec.VLInt")
	proto.RegisterType((*VLDblDbl)(nil), "github.com.wyndhblb.fvec.VLDblDbl")
	proto.RegisterType((*VLDblStr)(nil), "github.com.wyndhblb.fvec.VLDblStr")
	proto.RegisterType((*VLDblInt)(nil), "github.com.wyndhblb.fvec.VLDblInt")
	proto.RegisterType((*VLStrDbl)(nil), "github.com.wyndhblb.fvec.VLStrDbl")
	proto.RegisterType((*VLStrStr)(nil), "github.com.wyndhblb.fvec.VLStrStr")
	proto.RegisterType((*VLStrInt)(nil), "github.com.wyndhblb.fvec.VLStrInt")
	proto.RegisterType((*VLIntDbl)(nil), "github.com.wyndhblb.fvec.VLIntDbl")
	proto.RegisterType((*VLIntStr)(nil), "github.com.wyndhblb.fvec.VLIntStr")
	proto.RegisterType((*VLIntInt)(nil), "github.com.wyndhblb.fvec.VLIntInt")
	proto.RegisterType((*VSDbl)(nil), "github.com.wyndhblb.fvec.VSDbl")
	proto.RegisterType((*VSStr)(nil), "github.com.wyndhblb.fvec.VSStr")
	proto.RegisterType((*VSInt)(nil), "github.com.wyndhblb.fvec.VSInt")
	proto.RegisterType((*VSDblDbl)(nil), "github.com.wyndhblb.fvec.VSDblDbl")
	proto.RegisterType((*VSDblStr)(nil), "github.com.wyndhblb.fvec.VSDblStr")
	proto.RegisterType((*VSDblInt)(nil), "github.com.wyndhblb.fvec.VSDblInt")
	proto.RegisterType((*VSStrDbl)(nil), "github.com.wyndhblb.fvec.VSStrDbl")
	proto.RegisterType((*VSStrStr)(nil), "github.com.wyndhblb.fvec.VSStrStr")
	proto.RegisterType((*VSStrInt)(nil), "github.com.wyndhblb.fvec.VSStrInt")
	proto.RegisterType((*VSIntDbl)(nil), "github.com.wyndhblb.fvec.VSIntDbl")
	proto.RegisterType((*VSIntStr)(nil), "github.com.wyndhblb.fvec.VSIntStr")
	proto.RegisterType((*VSIntInt)(nil), "github.com.wyndhblb.fvec.VSIntInt")
	proto.RegisterType((*VMStrDbl)(nil), "github.com.wyndhblb.fvec.VMStrDbl")
	proto.RegisterType((*VMStrStr)(nil), "github.com.wyndhblb.fvec.VMStrStr")
	proto.RegisterType((*VMStrInt)(nil), "github.com.wyndhblb.fvec.VMStrInt")
	proto.RegisterType((*VMIntDbl)(nil), "github.com.wyndhblb.fvec.VMIntDbl")
	proto.RegisterType((*VMIntStr)(nil), "github.com.wyndhblb.fvec.VMIntStr")
	proto.RegisterType((*VMIntInt)(nil), "github.com.wyndhblb.fvec.VMIntInt")
	proto.RegisterType((*VMStrTPDblDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPDblDbl")
	proto.RegisterType((*VMStrTPDblStr)(nil), "github.com.wyndhblb.fvec.VMStrTPDblStr")
	proto.RegisterType((*VMStrTPDblInt)(nil), "github.com.wyndhblb.fvec.VMStrTPDblInt")
	proto.RegisterType((*VMStrTPStrDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPStrDbl")
	proto.RegisterType((*VMStrTPStrStr)(nil), "github.com.wyndhblb.fvec.VMStrTPStrStr")
	proto.RegisterType((*VMStrTPStrInt)(nil), "github.com.wyndhblb.fvec.VMStrTPStrInt")
	proto.RegisterType((*VMStrTPIntDbl)(nil), "github.com.wyndhblb.fvec.VMStrTPIntDbl")
	proto.RegisterType((*VMStrTPIntStr)(nil), "github.com.wyndhblb.fvec.VMStrTPIntStr")
	proto.RegisterType((*VMStrTPIntInt)(nil), "github.com.wyndhblb.fvec.VMStrTPIntInt")
	proto.RegisterType((*VMIntTPDblDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPDblDbl")
	proto.RegisterType((*VMIntTPDblStr)(nil), "github.com.wyndhblb.fvec.VMIntTPDblStr")
	proto.RegisterType((*VMIntTPDblInt)(nil), "github.com.wyndhblb.fvec.VMIntTPDblInt")
	proto.RegisterType((*VMIntTPStrDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPStrDbl")
	proto.RegisterType((*VMIntTPStrStr)(nil), "github.com.wyndhblb.fvec.VMIntTPStrStr")
	proto.RegisterType((*VMIntTPStrInt)(nil), "github.com.wyndhblb.fvec.VMIntTPStrInt")
	proto.RegisterType((*VMIntTPIntDbl)(nil), "github.com.wyndhblb.fvec.VMIntTPIntDbl")
	proto.RegisterType((*VMIntTPIntStr)(nil), "github.com.wyndhblb.fvec.VMIntTPIntStr")
	proto.RegisterType((*VMIntTPIntInt)(nil), "github.com.wyndhblb.fvec.VMIntTPIntInt")
}
func (m *Tag) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Tag) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VName) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VName) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Resolution != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFvec(data, i, uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintFvec(data, i, uint64(m.Ttl))
	}
	if m.XUniqueId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintFvec(data, i, uint64(m.XUniqueId))
	}
	if len(m.XUniqueStr) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.XUniqueStr)))
		i += copy(data[i:], m.XUniqueStr)
	}
	if m.Time != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFvec(data, i, uint64(m.Time))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x5a
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VTDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VTDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Key))))
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFvec(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VTStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VTStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFvec(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VTIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFvec(data, i, uint64(m.Key))
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *VTIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFvec(data, i, uint64(m.Key))
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *VTIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VTIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFvec(data, i, uint64(m.Key))
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFvec(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *VLDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Vec)*8))
		for _, num := range m.Vec {
			f1 := math.Float64bits(float64(num))
			data[i] = uint8(f1)
			i++
			data[i] = uint8(f1 >> 8)
			i++
			data[i] = uint8(f1 >> 16)
			i++
			data[i] = uint8(f1 >> 24)
			i++
			data[i] = uint8(f1 >> 32)
			i++
			data[i] = uint8(f1 >> 40)
			i++
			data[i] = uint8(f1 >> 48)
			i++
			data[i] = uint8(f1 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *VLStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VLInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		data3 := make([]byte, len(m.Vec)*10)
		var j2 int
		for _, num1 := range m.Vec {
			num := uint64(num1)
			for num >= 1<<7 {
				data3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			data3[j2] = uint8(num)
			j2++
		}
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(j2))
		i += copy(data[i:], data3[:j2])
	}
	return i, nil
}

func (m *VLDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VLIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VLIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(len(m.Vec)*8))
		for _, num := range m.Vec {
			f4 := math.Float64bits(float64(num))
			data[i] = uint8(f4)
			i++
			data[i] = uint8(f4 >> 8)
			i++
			data[i] = uint8(f4 >> 16)
			i++
			data[i] = uint8(f4 >> 24)
			i++
			data[i] = uint8(f4 >> 32)
			i++
			data[i] = uint8(f4 >> 40)
			i++
			data[i] = uint8(f4 >> 48)
			i++
			data[i] = uint8(f4 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *VSStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VSInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		data6 := make([]byte, len(m.Vec)*10)
		var j5 int
		for _, num1 := range m.Vec {
			num := uint64(num1)
			for num >= 1<<7 {
				data6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			data6[j5] = uint8(num)
			j5++
		}
		data[i] = 0xa
		i++
		i = encodeVarintFvec(data, i, uint64(j5))
		i += copy(data[i:], data6[:j5])
	}
	return i, nil
}

func (m *VSDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VSIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VSIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, msg := range m.Vec {
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VMStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + 8
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x11
			i++
			i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *VMStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + len(v) + sovFvec(uint64(len(v)))
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintFvec(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *VMStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + sovFvec(uint64(v))
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintFvec(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *VMIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + sovFvec(uint64(k)) + 1 + 8
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			data[i] = 0x11
			i++
			i = encodeFixed64Fvec(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *VMIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + sovFvec(uint64(k)) + 1 + len(v) + sovFvec(uint64(len(v)))
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintFvec(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *VMIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			mapSize := 1 + sovFvec(uint64(k)) + 1 + sovFvec(uint64(v))
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintFvec(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *VMStrTPDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n7, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *VMStrTPDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n8, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *VMStrTPDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n9, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n10, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n11, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func (m *VMStrTPStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n12, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n13, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n14, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	return i, nil
}

func (m *VMStrTPIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMStrTPIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovFvec(uint64(len(k))) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFvec(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n15, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	return i, nil
}

func (m *VMIntTPDblDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n16, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	return i, nil
}

func (m *VMIntTPDblStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n17, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	return i, nil
}

func (m *VMIntTPDblInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPDblInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n18, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n19, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n20, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n20
			}
		}
	}
	return i, nil
}

func (m *VMIntTPStrInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPStrInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n21, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntDbl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntDbl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n22, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntStr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntStr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n23, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	return i, nil
}

func (m *VMIntTPIntInt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VMIntTPIntInt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k := range m.Vec {
			data[i] = 0xa
			i++
			v := m.Vec[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovFvec(uint64(msgSize))
			}
			mapSize := 1 + sovFvec(uint64(k)) + msgSize
			i = encodeVarintFvec(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintFvec(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintFvec(data, i, uint64(v.Size()))
				n24, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n24
			}
		}
	}
	return i, nil
}

func encodeFixed64Fvec(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Fvec(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFvec(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTag(r randyFvec, easy bool) *Tag {
	this := &Tag{}
	this.Name = randStringFvec(r)
	this.Value = randStringFvec(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVName(r randyFvec, easy bool) *VName {
	this := &VName{}
	this.Key = randStringFvec(r)
	this.Resolution = github_com_wyndhblb_timeslab.Resolution([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}[r.Intn(15)])
	this.Ttl = uint32(r.Uint32())
	this.XUniqueId = uint64(uint64(r.Uint32()))
	this.XUniqueStr = randStringFvec(r)
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Tags = make([]*Tag, v1)
		for i := 0; i < v1; i++ {
			this.Tags[i] = NewPopulatedTag(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblDbl(r randyFvec, easy bool) *VTDblDbl {
	this := &VTDblDbl{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblStr(r randyFvec, easy bool) *VTDblStr {
	this := &VTDblStr{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = randStringFvec(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTDblInt(r randyFvec, easy bool) *VTDblInt {
	this := &VTDblInt{}
	this.Key = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrDbl(r randyFvec, easy bool) *VTStrDbl {
	this := &VTStrDbl{}
	this.Key = randStringFvec(r)
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrStr(r randyFvec, easy bool) *VTStrStr {
	this := &VTStrStr{}
	this.Key = randStringFvec(r)
	this.Value = randStringFvec(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTStrInt(r randyFvec, easy bool) *VTStrInt {
	this := &VTStrInt{}
	this.Key = randStringFvec(r)
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntDbl(r randyFvec, easy bool) *VTIntDbl {
	this := &VTIntDbl{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntStr(r randyFvec, easy bool) *VTIntStr {
	this := &VTIntStr{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = randStringFvec(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVTIntInt(r randyFvec, easy bool) *VTIntInt {
	this := &VTIntInt{}
	this.Key = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Key *= -1
	}
	this.Value = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDbl(r randyFvec, easy bool) *VLDbl {
	this := &VLDbl{}
	v2 := r.Intn(10)
	this.Vec = make([]float64, v2)
	for i := 0; i < v2; i++ {
		this.Vec[i] = float64(r.Float64())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStr(r randyFvec, easy bool) *VLStr {
	this := &VLStr{}
	v3 := r.Intn(10)
	this.Vec = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.Vec[i] = randStringFvec(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLInt(r randyFvec, easy bool) *VLInt {
	this := &VLInt{}
	v4 := r.Intn(10)
	this.Vec = make([]int64, v4)
	for i := 0; i < v4; i++ {
		this.Vec[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblDbl(r randyFvec, easy bool) *VLDblDbl {
	this := &VLDblDbl{}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Vec = make([]*VTDblDbl, v5)
		for i := 0; i < v5; i++ {
			this.Vec[i] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblStr(r randyFvec, easy bool) *VLDblStr {
	this := &VLDblStr{}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Vec = make([]*VTDblStr, v6)
		for i := 0; i < v6; i++ {
			this.Vec[i] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLDblInt(r randyFvec, easy bool) *VLDblInt {
	this := &VLDblInt{}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Vec = make([]*VTDblInt, v7)
		for i := 0; i < v7; i++ {
			this.Vec[i] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrDbl(r randyFvec, easy bool) *VLStrDbl {
	this := &VLStrDbl{}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Vec = make([]*VTStrDbl, v8)
		for i := 0; i < v8; i++ {
			this.Vec[i] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrStr(r randyFvec, easy bool) *VLStrStr {
	this := &VLStrStr{}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Vec = make([]*VTStrStr, v9)
		for i := 0; i < v9; i++ {
			this.Vec[i] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLStrInt(r randyFvec, easy bool) *VLStrInt {
	this := &VLStrInt{}
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Vec = make([]*VTStrInt, v10)
		for i := 0; i < v10; i++ {
			this.Vec[i] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntDbl(r randyFvec, easy bool) *VLIntDbl {
	this := &VLIntDbl{}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.Vec = make([]*VTIntDbl, v11)
		for i := 0; i < v11; i++ {
			this.Vec[i] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntStr(r randyFvec, easy bool) *VLIntStr {
	this := &VLIntStr{}
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.Vec = make([]*VTIntStr, v12)
		for i := 0; i < v12; i++ {
			this.Vec[i] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVLIntInt(r randyFvec, easy bool) *VLIntInt {
	this := &VLIntInt{}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Vec = make([]*VTIntInt, v13)
		for i := 0; i < v13; i++ {
			this.Vec[i] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDbl(r randyFvec, easy bool) *VSDbl {
	this := &VSDbl{}
	v14 := r.Intn(10)
	this.Vec = make([]float64, v14)
	for i := 0; i < v14; i++ {
		this.Vec[i] = float64(r.Float64())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStr(r randyFvec, easy bool) *VSStr {
	this := &VSStr{}
	v15 := r.Intn(10)
	this.Vec = make([]string, v15)
	for i := 0; i < v15; i++ {
		this.Vec[i] = randStringFvec(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSInt(r randyFvec, easy bool) *VSInt {
	this := &VSInt{}
	v16 := r.Intn(10)
	this.Vec = make([]int64, v16)
	for i := 0; i < v16; i++ {
		this.Vec[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Vec[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblDbl(r randyFvec, easy bool) *VSDblDbl {
	this := &VSDblDbl{}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Vec = make([]*VTDblDbl, v17)
		for i := 0; i < v17; i++ {
			this.Vec[i] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblStr(r randyFvec, easy bool) *VSDblStr {
	this := &VSDblStr{}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Vec = make([]*VTDblStr, v18)
		for i := 0; i < v18; i++ {
			this.Vec[i] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSDblInt(r randyFvec, easy bool) *VSDblInt {
	this := &VSDblInt{}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Vec = make([]*VTDblInt, v19)
		for i := 0; i < v19; i++ {
			this.Vec[i] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrDbl(r randyFvec, easy bool) *VSStrDbl {
	this := &VSStrDbl{}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Vec = make([]*VTStrDbl, v20)
		for i := 0; i < v20; i++ {
			this.Vec[i] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrStr(r randyFvec, easy bool) *VSStrStr {
	this := &VSStrStr{}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Vec = make([]*VTStrStr, v21)
		for i := 0; i < v21; i++ {
			this.Vec[i] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSStrInt(r randyFvec, easy bool) *VSStrInt {
	this := &VSStrInt{}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.Vec = make([]*VTStrInt, v22)
		for i := 0; i < v22; i++ {
			this.Vec[i] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntDbl(r randyFvec, easy bool) *VSIntDbl {
	this := &VSIntDbl{}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Vec = make([]*VTIntDbl, v23)
		for i := 0; i < v23; i++ {
			this.Vec[i] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntStr(r randyFvec, easy bool) *VSIntStr {
	this := &VSIntStr{}
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.Vec = make([]*VTIntStr, v24)
		for i := 0; i < v24; i++ {
			this.Vec[i] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVSIntInt(r randyFvec, easy bool) *VSIntInt {
	this := &VSIntInt{}
	if r.Intn(10) != 0 {
		v25 := r.Intn(5)
		this.Vec = make([]*VTIntInt, v25)
		for i := 0; i < v25; i++ {
			this.Vec[i] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrDbl(r randyFvec, easy bool) *VMStrDbl {
	this := &VMStrDbl{}
	if r.Intn(10) != 0 {
		v26 := r.Intn(10)
		this.Vec = make(map[string]float64)
		for i := 0; i < v26; i++ {
			v27 := randStringFvec(r)
			this.Vec[v27] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Vec[v27] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrStr(r randyFvec, easy bool) *VMStrStr {
	this := &VMStrStr{}
	if r.Intn(10) != 0 {
		v28 := r.Intn(10)
		this.Vec = make(map[string]string)
		for i := 0; i < v28; i++ {
			this.Vec[randStringFvec(r)] = randStringFvec(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrInt(r randyFvec, easy bool) *VMStrInt {
	this := &VMStrInt{}
	if r.Intn(10) != 0 {
		v29 := r.Intn(10)
		this.Vec = make(map[string]int64)
		for i := 0; i < v29; i++ {
			v30 := randStringFvec(r)
			this.Vec[v30] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Vec[v30] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntDbl(r randyFvec, easy bool) *VMIntDbl {
	this := &VMIntDbl{}
	if r.Intn(10) != 0 {
		v31 := r.Intn(10)
		this.Vec = make(map[int64]float64)
		for i := 0; i < v31; i++ {
			v32 := int64(r.Int63())
			this.Vec[v32] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Vec[v32] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntStr(r randyFvec, easy bool) *VMIntStr {
	this := &VMIntStr{}
	if r.Intn(10) != 0 {
		v33 := r.Intn(10)
		this.Vec = make(map[int64]string)
		for i := 0; i < v33; i++ {
			this.Vec[int64(r.Int63())] = randStringFvec(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntInt(r randyFvec, easy bool) *VMIntInt {
	this := &VMIntInt{}
	if r.Intn(10) != 0 {
		v34 := r.Intn(10)
		this.Vec = make(map[int64]int64)
		for i := 0; i < v34; i++ {
			v35 := int64(r.Int63())
			this.Vec[v35] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Vec[v35] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblDbl(r randyFvec, easy bool) *VMStrTPDblDbl {
	this := &VMStrTPDblDbl{}
	if r.Intn(10) != 0 {
		v36 := r.Intn(10)
		this.Vec = make(map[string]*VTDblDbl)
		for i := 0; i < v36; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblStr(r randyFvec, easy bool) *VMStrTPDblStr {
	this := &VMStrTPDblStr{}
	if r.Intn(10) != 0 {
		v37 := r.Intn(10)
		this.Vec = make(map[string]*VTDblStr)
		for i := 0; i < v37; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPDblInt(r randyFvec, easy bool) *VMStrTPDblInt {
	this := &VMStrTPDblInt{}
	if r.Intn(10) != 0 {
		v38 := r.Intn(10)
		this.Vec = make(map[string]*VTDblInt)
		for i := 0; i < v38; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrDbl(r randyFvec, easy bool) *VMStrTPStrDbl {
	this := &VMStrTPStrDbl{}
	if r.Intn(10) != 0 {
		v39 := r.Intn(10)
		this.Vec = make(map[string]*VTStrDbl)
		for i := 0; i < v39; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrStr(r randyFvec, easy bool) *VMStrTPStrStr {
	this := &VMStrTPStrStr{}
	if r.Intn(10) != 0 {
		v40 := r.Intn(10)
		this.Vec = make(map[string]*VTStrStr)
		for i := 0; i < v40; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPStrInt(r randyFvec, easy bool) *VMStrTPStrInt {
	this := &VMStrTPStrInt{}
	if r.Intn(10) != 0 {
		v41 := r.Intn(10)
		this.Vec = make(map[string]*VTStrInt)
		for i := 0; i < v41; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntDbl(r randyFvec, easy bool) *VMStrTPIntDbl {
	this := &VMStrTPIntDbl{}
	if r.Intn(10) != 0 {
		v42 := r.Intn(10)
		this.Vec = make(map[string]*VTIntDbl)
		for i := 0; i < v42; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntStr(r randyFvec, easy bool) *VMStrTPIntStr {
	this := &VMStrTPIntStr{}
	if r.Intn(10) != 0 {
		v43 := r.Intn(10)
		this.Vec = make(map[string]*VTIntStr)
		for i := 0; i < v43; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMStrTPIntInt(r randyFvec, easy bool) *VMStrTPIntInt {
	this := &VMStrTPIntInt{}
	if r.Intn(10) != 0 {
		v44 := r.Intn(10)
		this.Vec = make(map[string]*VTIntInt)
		for i := 0; i < v44; i++ {
			this.Vec[randStringFvec(r)] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblDbl(r randyFvec, easy bool) *VMIntTPDblDbl {
	this := &VMIntTPDblDbl{}
	if r.Intn(10) != 0 {
		v45 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblDbl)
		for i := 0; i < v45; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblStr(r randyFvec, easy bool) *VMIntTPDblStr {
	this := &VMIntTPDblStr{}
	if r.Intn(10) != 0 {
		v46 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblStr)
		for i := 0; i < v46; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPDblInt(r randyFvec, easy bool) *VMIntTPDblInt {
	this := &VMIntTPDblInt{}
	if r.Intn(10) != 0 {
		v47 := r.Intn(10)
		this.Vec = make(map[int64]*VTDblInt)
		for i := 0; i < v47; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTDblInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrDbl(r randyFvec, easy bool) *VMIntTPStrDbl {
	this := &VMIntTPStrDbl{}
	if r.Intn(10) != 0 {
		v48 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrDbl)
		for i := 0; i < v48; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrStr(r randyFvec, easy bool) *VMIntTPStrStr {
	this := &VMIntTPStrStr{}
	if r.Intn(10) != 0 {
		v49 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrStr)
		for i := 0; i < v49; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPStrInt(r randyFvec, easy bool) *VMIntTPStrInt {
	this := &VMIntTPStrInt{}
	if r.Intn(10) != 0 {
		v50 := r.Intn(10)
		this.Vec = make(map[int64]*VTStrInt)
		for i := 0; i < v50; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTStrInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntDbl(r randyFvec, easy bool) *VMIntTPIntDbl {
	this := &VMIntTPIntDbl{}
	if r.Intn(10) != 0 {
		v51 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntDbl)
		for i := 0; i < v51; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntDbl(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntStr(r randyFvec, easy bool) *VMIntTPIntStr {
	this := &VMIntTPIntStr{}
	if r.Intn(10) != 0 {
		v52 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntStr)
		for i := 0; i < v52; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntStr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVMIntTPIntInt(r randyFvec, easy bool) *VMIntTPIntInt {
	this := &VMIntTPIntInt{}
	if r.Intn(10) != 0 {
		v53 := r.Intn(10)
		this.Vec = make(map[int64]*VTIntInt)
		for i := 0; i < v53; i++ {
			this.Vec[int64(r.Int63())] = NewPopulatedVTIntInt(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyFvec interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneFvec(r randyFvec) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringFvec(r randyFvec) string {
	v54 := r.Intn(100)
	tmps := make([]rune, v54)
	for i := 0; i < v54; i++ {
		tmps[i] = randUTF8RuneFvec(r)
	}
	return string(tmps)
}
func randUnrecognizedFvec(r randyFvec, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldFvec(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldFvec(data []byte, r randyFvec, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateFvec(data, uint64(key))
		v55 := r.Int63()
		if r.Intn(2) == 0 {
			v55 *= -1
		}
		data = encodeVarintPopulateFvec(data, uint64(v55))
	case 1:
		data = encodeVarintPopulateFvec(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateFvec(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateFvec(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateFvec(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateFvec(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	return n
}

func (m *VName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovFvec(uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		n += 1 + sovFvec(uint64(m.Ttl))
	}
	if m.XUniqueId != 0 {
		n += 1 + sovFvec(uint64(m.XUniqueId))
	}
	l = len(m.XUniqueStr)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovFvec(uint64(m.Time))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VTDblDbl) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTDblStr) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	return n
}

func (m *VTDblInt) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 1 + sovFvec(uint64(m.Value))
	}
	return n
}

func (m *VTStrDbl) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTStrStr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	return n
}

func (m *VTStrInt) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFvec(uint64(m.Value))
	}
	return n
}

func (m *VTIntDbl) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovFvec(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *VTIntStr) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovFvec(uint64(m.Key))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFvec(uint64(l))
	}
	return n
}

func (m *VTIntInt) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovFvec(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovFvec(uint64(m.Value))
	}
	return n
}

func (m *VLDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		n += 1 + sovFvec(uint64(len(m.Vec)*8)) + len(m.Vec)*8
	}
	return n
}

func (m *VLStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			l = len(s)
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		l = 0
		for _, e := range m.Vec {
			l += sovFvec(uint64(e))
		}
		n += 1 + sovFvec(uint64(l)) + l
	}
	return n
}

func (m *VLDblDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLDblStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLDblInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLStrDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLStrStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLStrInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLIntDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLIntStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VLIntInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		n += 1 + sovFvec(uint64(len(m.Vec)*8)) + len(m.Vec)*8
	}
	return n
}

func (m *VSStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, s := range m.Vec {
			l = len(s)
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		l = 0
		for _, e := range m.Vec {
			l += sovFvec(uint64(e))
		}
		n += 1 + sovFvec(uint64(l)) + l
	}
	return n
}

func (m *VSDblDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSDblStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSDblInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSStrDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSStrStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSStrInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSIntDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSIntStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VSIntInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for _, e := range m.Vec {
			l = e.Size()
			n += 1 + l + sovFvec(uint64(l))
		}
	}
	return n
}

func (m *VMStrDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + len(v) + sovFvec(uint64(len(v)))
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + 1 + sovFvec(uint64(v))
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFvec(uint64(k)) + 1 + 8
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFvec(uint64(k)) + 1 + len(v) + sovFvec(uint64(len(v)))
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFvec(uint64(k)) + 1 + sovFvec(uint64(v))
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPDblInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPStrInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMStrTPIntInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFvec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPDblInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPStrInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntDbl) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntStr) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VMIntTPIntInt) Size() (n int) {
	var l int
	_ = l
	if len(m.Vec) > 0 {
		for k, v := range m.Vec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFvec(uint64(l))
			}
			mapEntrySize := 1 + sovFvec(uint64(k)) + l
			n += mapEntrySize + 1 + sovFvec(uint64(mapEntrySize))
		}
	}
	return n
}

func sovFvec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFvec(x uint64) (n int) {
	return sovFvec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tag) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VName) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (github_com_wyndhblb_timeslab.Resolution(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XUniqueId", wireType)
			}
			m.XUniqueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.XUniqueId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XUniqueStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XUniqueStr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Key = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFvec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vec = append(m.Vec, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vec = append(m.Vec, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFvec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFvec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vec = append(m.Vec, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec = append(m.Vec, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFvec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vec = append(m.Vec, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vec = append(m.Vec, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFvec
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFvec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vec = append(m.Vec, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec = append(m.Vec, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTDblInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTStrInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntDbl{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntStr{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vec = append(m.Vec, &VTIntInt{})
			if err := m.Vec[len(m.Vec)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthFvec
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthFvec
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTDblInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTStrInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMStrTPIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMStrTPIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMStrTPIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFvec
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Vec == nil {
				m.Vec = make(map[string]*VTIntInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPDblInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPDblInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPDblInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTDblInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTDblInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTDblInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPStrInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPStrInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPStrInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTStrInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTStrInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTStrInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntDbl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntDbl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntDbl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntDbl)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntDbl{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntDbl
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntStr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntStr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntStr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntStr)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntStr{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntStr
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMIntTPIntInt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMIntTPIntInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMIntTPIntInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFvec
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Vec == nil {
				m.Vec = make(map[int64]*VTIntInt)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthFvec
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &VTIntInt{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Vec[mapkey] = mapvalue
			} else {
				var mapvalue *VTIntInt
				m.Vec[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFvec(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFvec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFvec(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFvec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFvec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFvec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFvec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFvec(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFvec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFvec   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fvec.proto", fileDescriptorFvec) }

var fileDescriptorFvec = []byte{
	// 922 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x99, 0xc1, 0x6a, 0xdb, 0x4a,
	0x14, 0x86, 0x33, 0x19, 0x3b, 0x58, 0x13, 0x72, 0xb9, 0xe8, 0xde, 0x85, 0x1a, 0xa8, 0x63, 0xbc,
	0x32, 0x84, 0xc8, 0xad, 0x5b, 0x4a, 0x28, 0x14, 0x8a, 0x49, 0xa1, 0x82, 0xb6, 0x14, 0x8f, 0x6b,
	0x4a, 0x36, 0xc5, 0x76, 0x14, 0xc7, 0xd4, 0x91, 0x5b, 0x79, 0xe4, 0x92, 0x65, 0xdf, 0xa0, 0xaf,
	0xd0, 0x27, 0xe8, 0x2b, 0x74, 0x99, 0x65, 0x9f, 0x20, 0x34, 0xee, 0xae, 0x4f, 0xd0, 0x65, 0x99,
	0xd1, 0x28, 0x1e, 0xc9, 0x9a, 0x48, 0x23, 0xc9, 0x3b, 0xc9, 0xa3, 0xff, 0x9f, 0x4f, 0x73, 0x7e,
	0xce, 0x11, 0x18, 0xa1, 0xd3, 0xb9, 0x3d, 0x34, 0x3f, 0xb8, 0x53, 0x32, 0xd5, 0x8d, 0xd1, 0x98,
	0x9c, 0x79, 0x03, 0x73, 0x38, 0x3d, 0x37, 0x3f, 0x5d, 0x38, 0x27, 0x67, 0x83, 0xc9, 0xc0, 0xa4,
	0xeb, 0xbb, 0x07, 0xcb, 0x95, 0xe6, 0x68, 0x3a, 0x9a, 0x36, 0x99, 0x60, 0xe0, 0x9d, 0xb2, 0x3b,
	0x76, 0xc3, 0xae, 0x7c, 0xa3, 0xdd, 0x7d, 0xe1, 0xf1, 0xc0, 0xa8, 0x49, 0xc6, 0xe7, 0xf6, 0x6c,
	0xd2, 0x5f, 0x5e, 0xf8, 0x0f, 0xd7, 0x9b, 0x08, 0x76, 0xfb, 0x23, 0x5d, 0x47, 0x25, 0xa7, 0x7f,
	0x6e, 0x1b, 0xa0, 0x06, 0x1a, 0x5a, 0x87, 0x5d, 0xeb, 0xff, 0xa3, 0xf2, 0xbc, 0x3f, 0xf1, 0x6c,
	0x63, 0x93, 0xfd, 0xe8, 0xdf, 0xd4, 0xbf, 0x6e, 0xa2, 0x72, 0xef, 0x15, 0x5d, 0xff, 0x17, 0xc1,
	0xf7, 0xf6, 0x05, 0x97, 0xd0, 0x4b, 0xfd, 0x39, 0x42, 0xae, 0x3d, 0x9b, 0x4e, 0x3c, 0x32, 0x9e,
	0x3a, 0x4c, 0xf6, 0x4f, 0xab, 0x61, 0xc6, 0xbd, 0xd7, 0x0d, 0x45, 0xe7, 0xe6, 0xf9, 0x8e, 0xa0,
	0xa5, 0xde, 0x84, 0x4c, 0x0c, 0x58, 0x03, 0x8d, 0x9d, 0x0e, 0xbd, 0xd4, 0x9b, 0x48, 0xf3, 0x9c,
	0xf1, 0x47, 0xcf, 0x7e, 0x37, 0x3e, 0x31, 0x4a, 0x35, 0xd0, 0x28, 0xb5, 0xf5, 0xc5, 0xd5, 0x9e,
	0xf6, 0xf6, 0x0d, 0xfb, 0xd5, 0x3a, 0xf9, 0x7d, 0xb5, 0x07, 0x0e, 0x3a, 0x15, 0x8f, 0xdf, 0xea,
	0x2d, 0x84, 0xb8, 0x60, 0x46, 0x5c, 0xa3, 0x4c, 0x29, 0xdb, 0xff, 0x2d, 0xae, 0xf6, 0x10, 0x57,
	0x60, 0xe2, 0xfa, 0x12, 0xee, 0x8b, 0x89, 0x4b, 0x8f, 0x81, 0x92, 0x19, 0x5b, 0x35, 0xd0, 0x80,
	0x1d, 0x76, 0xad, 0xdf, 0x47, 0x25, 0xd2, 0x1f, 0xcd, 0x8c, 0xed, 0x1a, 0x6c, 0x6c, 0xb7, 0xee,
	0x9a, 0xb2, 0x32, 0x99, 0xdd, 0xfe, 0xa8, 0xc3, 0x1e, 0xad, 0xb7, 0x50, 0xa5, 0xd7, 0x3d, 0x1a,
	0x4c, 0x8e, 0x06, 0x13, 0xf1, 0x94, 0x80, 0x7f, 0x4a, 0xa1, 0x73, 0x05, 0xc1, 0xb9, 0x06, 0x1a,
	0x8a, 0x91, 0xa0, 0xd1, 0xa2, 0x1a, 0xcb, 0x21, 0x49, 0x1a, 0x18, 0xd2, 0x60, 0xe2, 0x46, 0xd8,
	0xb4, 0x44, 0x36, 0x4c, 0xdc, 0x08, 0x9b, 0x96, 0xc8, 0x86, 0x89, 0x1b, 0x61, 0xd3, 0x12, 0xd9,
	0x2c, 0x87, 0x44, 0xd8, 0x60, 0x22, 0x9b, 0xe5, 0x90, 0x08, 0x1b, 0x4c, 0x64, 0xb3, 0x1c, 0x12,
	0x61, 0x83, 0xb7, 0xb1, 0xdd, 0x41, 0xe5, 0xde, 0x0b, 0x0e, 0x36, 0xb7, 0x87, 0x06, 0xa8, 0x41,
	0x7a, 0xd0, 0x73, 0x7b, 0xe8, 0x2f, 0xf1, 0xfd, 0x83, 0x25, 0x4d, 0x58, 0xe2, 0xdb, 0x04, 0x4b,
	0xd0, 0x5f, 0x7a, 0x8a, 0x2a, 0xcc, 0x90, 0x7a, 0x3e, 0x5c, 0xae, 0x6e, 0xb7, 0xea, 0xf2, 0x88,
	0x05, 0xa9, 0x0a, 0x3b, 0xd0, 0xad, 0x95, 0x1c, 0x30, 0x71, 0xc3, 0x0e, 0x94, 0x50, 0xc9, 0xc1,
	0x72, 0x88, 0xe0, 0xc0, 0xe3, 0x94, 0xde, 0xc1, 0x17, 0x84, 0x1d, 0xd4, 0xde, 0xc2, 0x17, 0x84,
	0x1d, 0xd4, 0xde, 0xc2, 0x17, 0x08, 0x0e, 0x3c, 0x78, 0xe9, 0x1d, 0x7c, 0x41, 0xd8, 0x41, 0xed,
	0x2d, 0x7c, 0x41, 0xd8, 0x41, 0xed, 0x2d, 0x7c, 0xc1, 0x32, 0x6c, 0x58, 0x1e, 0x51, 0x2c, 0x8f,
	0x28, 0x96, 0x47, 0x14, 0xe7, 0x8e, 0x28, 0xce, 0x1d, 0x51, 0x9c, 0x3b, 0xa2, 0x38, 0x77, 0x44,
	0x71, 0xee, 0x88, 0xe2, 0xdc, 0x11, 0xc5, 0xb9, 0x23, 0x8a, 0x73, 0x47, 0x14, 0xe7, 0x8a, 0xe8,
	0x67, 0x80, 0x2a, 0xbd, 0x97, 0xbc, 0x18, 0x4f, 0x44, 0x8b, 0xfd, 0x5b, 0x2c, 0xb8, 0xc0, 0xec,
	0xd9, 0xc3, 0x67, 0x0e, 0x71, 0x2f, 0x98, 0xd7, 0xee, 0x23, 0x54, 0x09, 0x7e, 0x48, 0x3b, 0xc9,
	0x1e, 0x6f, 0x1e, 0x82, 0x25, 0x03, 0x3d, 0x08, 0x25, 0x06, 0x4c, 0xdc, 0xec, 0x0c, 0x5a, 0x2c,
	0x03, 0x3d, 0x4a, 0x25, 0x06, 0xcb, 0x21, 0xd9, 0x19, 0xe0, 0x2a, 0x03, 0x8f, 0x54, 0x7a, 0x06,
	0x5f, 0x90, 0x8e, 0x01, 0xa6, 0xab, 0x05, 0x0f, 0xa5, 0x12, 0x43, 0xea, 0x5a, 0xc0, 0x74, 0xb5,
	0xe0, 0xb1, 0x56, 0x62, 0x48, 0x5d, 0x0b, 0x98, 0x54, 0x8b, 0x6f, 0x00, 0xed, 0xb0, 0xf2, 0x76,
	0x5f, 0xf3, 0x7e, 0xdb, 0x16, 0x41, 0xee, 0x25, 0x84, 0x22, 0x50, 0x45, 0x68, 0x8e, 0x6f, 0x4d,
	0xc6, 0xa1, 0x48, 0x93, 0xae, 0xa7, 0x4b, 0x89, 0x69, 0xf9, 0xd4, 0x89, 0x57, 0x6b, 0x58, 0x28,
	0x31, 0xed, 0x5b, 0x52, 0x62, 0x5a, 0x6c, 0x75, 0xe2, 0xd5, 0x8a, 0x17, 0x4a, 0x4c, 0xfb, 0x64,
	0x3c, 0x31, 0x6f, 0x99, 0x8a, 0xc4, 0xb1, 0x7d, 0xb3, 0x38, 0x62, 0x3e, 0x23, 0xa5, 0xc4, 0x19,
	0x52, 0x11, 0xdb, 0x65, 0x0b, 0x25, 0x96, 0xa7, 0x82, 0xb7, 0x63, 0x75, 0xe2, 0x75, 0xa6, 0x82,
	0x7f, 0x03, 0xc4, 0x13, 0xf3, 0xe6, 0xad, 0x48, 0x1c, 0xdb, 0xc1, 0x8b, 0x23, 0xe6, 0xdf, 0x1c,
	0x52, 0xe2, 0x0c, 0xa9, 0x88, 0xed, 0xf7, 0x85, 0x12, 0xcb, 0x53, 0xc1, 0x07, 0x83, 0x3a, 0xf1,
	0x3a, 0x53, 0xc1, 0xbf, 0xa9, 0x56, 0x88, 0x2d, 0x87, 0x64, 0x98, 0x20, 0x82, 0x2a, 0x1d, 0x31,
	0x2c, 0x6e, 0x82, 0x04, 0x7b, 0xab, 0xa5, 0x42, 0x50, 0xad, 0x93, 0x38, 0x36, 0x15, 0xc1, 0xde,
	0x6a, 0xa9, 0x10, 0x54, 0xeb, 0x24, 0x96, 0xa7, 0x42, 0x79, 0x82, 0x08, 0xaa, 0xb5, 0x11, 0xcb,
	0x26, 0x48, 0xb0, 0x77, 0x86, 0x54, 0xa8, 0x4c, 0x10, 0x58, 0xdc, 0x04, 0x09, 0xf6, 0xce, 0x90,
	0x0a, 0x95, 0x09, 0x02, 0x8b, 0x9b, 0x20, 0x6c, 0x6f, 0xe5, 0x09, 0x22, 0xa8, 0xd6, 0x46, 0x2c,
	0x9b, 0x20, 0xc1, 0xde, 0x19, 0x52, 0xa1, 0x32, 0x41, 0x60, 0x71, 0x13, 0x24, 0xd8, 0x3b, 0x43,
	0x2a, 0x54, 0x26, 0x08, 0x2c, 0x60, 0x82, 0xb4, 0xeb, 0x97, 0xd7, 0xd5, 0x8d, 0x3f, 0xd7, 0x55,
	0xf0, 0x7d, 0x51, 0x05, 0x97, 0x8b, 0x2a, 0xf8, 0xb1, 0xa8, 0x82, 0x9f, 0x8b, 0x2a, 0xf8, 0xf2,
	0xab, 0xba, 0x71, 0x5c, 0xa2, 0xba, 0xc1, 0x16, 0xfb, 0xd7, 0xe0, 0xc1, 0xdf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x71, 0xd4, 0x37, 0x5d, 0xb9, 0x18, 0x00, 0x00,
}
